{"task_id": "MBCPP/1", "completion": "    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    dp[0][0] = cost[0][0];\n\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = cost[i][j] + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\n        }\n    }\n\n    return dp[m][n];\n}", "unique_id": "MBCPP_1_9", "index": 8}
{"task_id": "MBCPP/2", "completion": "    vector<int> result;\n    unordered_set<int> elements(testTup1.begin(), testTup1.end());\n    for (int num : testTup2) {\n        if (elements.find(num) != elements.end()) {\n            result.push_back(num);\n        }\n    }\n    sort(result.begin(), result.end());\n    return result;\n}", "unique_id": "MBCPP_2_6", "index": 15}
{"task_id": "MBCPP/3", "completion": "    if (n <= 1) return true;\n    if (n == 2) return false;\n    if (n % 2 == 0) return true;\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        if (n % i == 0) return true;\n    }\n    return false;\n}", "unique_id": "MBCPP_3_1", "index": 20}
{"task_id": "MBCPP/4", "completion": "    priority_queue<int> maxHeap(nums.begin(), nums.end());\n    vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(maxHeap.top());\n        maxHeap.pop();\n    }\n    return result;\n}", "unique_id": "MBCPP_4_5", "index": 34}
{"task_id": "MBCPP/5", "completion": "    if (n % 2 != 0) return 0;\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[2] = 3;\n    for (int i = 4; i <= n; i += 2) {\n        dp[i] = 4 * dp[i - 2] - dp[i - 4];\n    }\n    return dp[n];\n}", "unique_id": "MBCPP_5_4", "index": 43}
{"task_id": "MBCPP/6", "completion": "    int x = a ^ b;\n    return x && !(x & (x - 1));\n}", "unique_id": "MBCPP_6_9", "index": 58}
{"task_id": "MBCPP/7", "completion": "    vector<string> result;\n    regex word_regex(\"\\\\b\\\\w{4,}\\\\b\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        result.push_back((*i).str());\n    }\n\n    return result;\n}", "unique_id": "MBCPP_7_10", "index": 69}
{"task_id": "MBCPP/8", "completion": "    transform(nums.begin(), nums.end(), nums.begin(), [](int x) { return x * x; });\n    return nums;\n}", "unique_id": "MBCPP_8_7", "index": 76}
{"task_id": "MBCPP/9", "completion": "    int n = str.length();\n    string temp = str + str;\n    for (int i = 1; i < n; i++) {\n        if (temp.substr(i, n) == str) {\n            return i;\n        }\n    }\n    return n;\n}", "unique_id": "MBCPP_9_4", "index": 83}
{"task_id": "MBCPP/10", "completion": "    sort(list1.begin(), list1.end());\n    return vector<int>(list1.begin(), list1.begin() + n);\n}", "unique_id": "MBCPP_10_2", "index": 91}
{"task_id": "MBCPP/11", "completion": "    size_t first = s.find(ch);\n    if (first != string::npos) {\n        s.erase(first, ch.length());\n    }\n\n    size_t last = s.rfind(ch);\n    if (last != string::npos) {\n        s.erase(last, ch.length());\n    }\n\n    return s;\n}", "unique_id": "MBCPP_11_2", "index": 101}
{"task_id": "MBCPP/12", "completion": "    sort(m.begin(), m.end(), [](const vector<int>& a, const vector<int>& b) {\n        return accumulate(a.begin(), a.end(), 0) < accumulate(b.begin(), b.end(), 0);\n    });\n    return m;\n}", "unique_id": "MBCPP_12_3", "index": 112}
{"task_id": "MBCPP/14", "completion": "    return (l * b * h) / 2;\n}", "unique_id": "MBCPP_14_5", "index": 124}
{"task_id": "MBCPP/15", "completion": "    vector<string> result;\n    string current;\n    for (char c : text) {\n        if (islower(c)) {\n            if (!current.empty()) {\n                result.push_back(current);\n                current.clear();\n            }\n            result.push_back(string(1, c));\n        } else {\n            current += c;\n        }\n    }\n    if (!current.empty()) {\n        result.push_back(current);\n    }\n    return result;\n}", "unique_id": "MBCPP_15_4", "index": 133}
{"task_id": "MBCPP/16", "completion": "    regex pattern(\"[a-z]+_[a-z]+\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_16_3", "index": 142}
{"task_id": "MBCPP/17", "completion": "    return 4 * a;\n}", "unique_id": "MBCPP_17_7", "index": 156}
{"task_id": "MBCPP/18", "completion": "    unordered_set<char> setChars(secondString.begin(), secondString.end());\n    string result;\n    for (char c : str) {\n        if (setChars.find(c) == setChars.end()) {\n            result += c;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_18_1", "index": 160}
{"task_id": "MBCPP/19", "completion": "    unordered_set<int> seen;\n    for (int num : arraynums) {\n        if (seen.find(num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}", "unique_id": "MBCPP_19_9", "index": 178}
{"task_id": "MBCPP/20", "completion": "    int n = 1;\n    while ((n * (1 << n) - 1) <= x) {\n        if ((n * (1 << n) - 1) == x)\n            return true;\n        n++;\n    }\n    return false;\n}", "unique_id": "MBCPP_20_9", "index": 188}
{"task_id": "MBCPP/21", "completion": "    vector<int> result;\n    for (int i = 1; i <= m; ++i) {\n        result.push_back(i * n);\n    }\n    return result;\n}", "unique_id": "MBCPP_21_8", "index": 197}
{"task_id": "MBCPP/22", "completion": "    unordered_set<int> seen;\n    for (int num : nums) {\n        if (seen.find(num) != seen.end()) {\n            return num;\n        }\n        seen.insert(num);\n    }\n    return -1;\n}", "unique_id": "MBCPP_22_8", "index": 207}
{"task_id": "MBCPP/23", "completion": "    int max_sum = INT_MIN;\n    for (const auto& lst : list1) {\n        int current_sum = accumulate(lst.begin(), lst.end(), 0);\n        max_sum = max(max_sum, current_sum);\n    }\n    return max_sum;\n}", "unique_id": "MBCPP_23_5", "index": 214}
{"task_id": "MBCPP/24", "completion": "    int decimal = 0, base = 1;\n    while (binary > 0) {\n        int last_digit = binary % 10;\n        binary = binary / 10;\n        decimal += last_digit * base;\n        base = base * 2;\n    }\n    return decimal;\n}", "unique_id": "MBCPP_24_3", "index": 222}
{"task_id": "MBCPP/25", "completion": "    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    int product = 1;\n    for (auto& entry : freq) {\n        if (entry.second == 1) {\n            product *= entry.first;\n        }\n    }\n    return product;\n}", "unique_id": "MBCPP_25_6", "index": 235}
{"task_id": "MBCPP/26", "completion": "    for (const auto& sublist : testList) {\n        if (sublist.size() != k) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_26_1", "index": 240}
{"task_id": "MBCPP/27", "completion": "    vector<string> result;\n    for (string &s : list) {\n        string filtered;\n        for (char c : s) {\n            if (!isdigit(c)) {\n                filtered += c;\n            }\n        }\n        result.push_back(filtered);\n    }\n    return result;\n}", "unique_id": "MBCPP_27_1", "index": 250}
{"task_id": "MBCPP/28", "completion": "    if (k > n) \n        return 0;\n    if (k == 0 || k == n)\n        return 1;\n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k);\n}", "unique_id": "MBCPP_28_10", "index": 269}
{"task_id": "MBCPP/29", "completion": "    unordered_map<int, int> freq;\n    for (int i = 0; i < arrSize; ++i) {\n        freq[arr[i]]++;\n    }\n    for (const auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            return pair.first;\n        }\n    }\n    return -1; // In case there is no element with odd occurrence\n}", "unique_id": "MBCPP_29_8", "index": 277}
{"task_id": "MBCPP/30", "completion": "    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    int result = 0;\n    for (auto& p : count) {\n        int n = p.second;\n        result += n * (n + 1) / 2;\n    }\n    return result;\n}", "unique_id": "MBCPP_30_9", "index": 288}
{"task_id": "MBCPP/31", "completion": "    unordered_map<int, int> freq;\n    for (const auto& list : nums) {\n        for (int num : list) {\n            freq[num]++;\n        }\n    }\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minHeap;\n    for (const auto& [num, count] : freq) {\n        minHeap.push({count, num});\n        if (minHeap.size() > k) {\n            minHeap.pop();\n        }\n    }\n\n    vector<int> result;\n    while (!minHeap.empty()) {\n        result.push_back(minHeap.top().second);\n        minHeap.pop();\n    }\n\n    reverse(result.begin(), result.end());\n    return result;\n}", "unique_id": "MBCPP_31_3", "index": 292}
{"task_id": "MBCPP/32", "completion": "    int maxPrime = -1;\n\n    // Divide n by 2 to get rid of all even factors\n    while (n % 2 == 0) {\n        maxPrime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, thus a skip of 2 (i.e., i = i + 2) can be used\n    for (int i = 3; i <= sqrt(n); i += 2) {\n        // While i divides n, update maxPrime and divide n by i\n        while (n % i == 0) {\n            maxPrime = i;\n            n /= i;\n        }\n    }\n\n    // This condition is to handle the case when n is a prime number\n    // greater than 2\n    if (n > 2)\n        maxPrime = n;\n\n    return maxPrime;\n}", "unique_id": "MBCPP_32_8", "index": 307}
{"task_id": "MBCPP/33", "completion": "    if (n == 0)\n        return 0;\n    int binary = 0, place = 1;\n    while (n > 0) {\n        binary += (n % 2) * place;\n        n /= 2;\n        place *= 10;\n    }\n    return binary;\n}", "unique_id": "MBCPP_33_8", "index": 317}
{"task_id": "MBCPP/34", "completion": "    int total = (n + 1) * (n + 2) / 2;\n    for (int i = 0; i < n; i++)\n        total -= ar[i];\n    return total;\n}", "unique_id": "MBCPP_34_4", "index": 323}
{"task_id": "MBCPP/35", "completion": "    return n * (n + 1);\n}", "unique_id": "MBCPP_35_4", "index": 333}
{"task_id": "MBCPP/36", "completion": "    string fraction = to_string((double)p / q);\n    int count = 0;\n    for (char c : fraction) {\n        if (c == '.') continue;\n        count++;\n        if (count == n) return c - '0';\n    }\n    return -1; // in case n is out of bounds\n}", "unique_id": "MBCPP_36_2", "index": 341}
{"task_id": "MBCPP/38", "completion": "    int firstEven = -1;\n    int firstOdd = -1;\n\n    for (int num : list1) {\n        if (num % 2 == 0 && firstEven == -1) {\n            firstEven = num;\n        } else if (num % 2 != 0 && firstOdd == -1) {\n            firstOdd = num;\n        }\n        if (firstEven != -1 && firstOdd != -1) {\n            break;\n        }\n    }\n\n    if (firstEven != -1 && firstOdd != -1) {\n        return firstEven / firstOdd;\n    } else {\n        return -1; // Return -1 if the division is not possible\n    }\n}", "unique_id": "MBCPP_38_6", "index": 355}
{"task_id": "MBCPP/39", "completion": "    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n\n    priority_queue<pair<int, char>> pq;\n    for (auto& [ch, cnt] : count) {\n        pq.push({cnt, ch});\n    }\n\n    string result;\n    pair<int, char> prev = {0, ' '};\n\n    while (!pq.empty()) {\n        auto [cnt, ch] = pq.top();\n        pq.pop();\n        result += ch;\n        cnt--;\n\n        if (prev.first > 0) {\n            pq.push(prev);\n        }\n\n        prev = {cnt, ch};\n    }\n\n    if (result.size() != s.size()) {\n        return \"\";\n    }\n\n    return result;\n}", "unique_id": "MBCPP_39_7", "index": 366}
{"task_id": "MBCPP/40", "completion": "    unordered_map<int, int> freq;\n    for (const auto& list : nums) {\n        for (const auto& num : list) {\n            freq[num]++;\n        }\n    }\n    return freq;\n}", "unique_id": "MBCPP_40_5", "index": 374}
{"task_id": "MBCPP/41", "completion": "    vector<int> result;\n    copy_if(nums.begin(), nums.end(), back_inserter(result), [](int n) { return n % 2 == 0; });\n    return result;\n}", "unique_id": "MBCPP_41_7", "index": 386}
{"task_id": "MBCPP/42", "completion": "    unordered_map<int, int> freq;\n    int sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        freq[arr[i]]++;\n    }\n\n    for (const auto& pair : freq) {\n        if (pair.second > 1) {\n            sum += pair.first * (pair.second - 1);\n        }\n    }\n\n    return sum;\n}", "unique_id": "MBCPP_42_1", "index": 390}
{"task_id": "MBCPP/43", "completion": "    regex pattern(\"[a-z]+_[a-z]+\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_43_7", "index": 406}
{"task_id": "MBCPP/44", "completion": "    if (text.find(\"python\") == 0) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_44_5", "index": 414}
{"task_id": "MBCPP/45", "completion": "    int gcd = l[0];\n    for (int i = 1; i < l.size(); i++) {\n        gcd = __gcd(gcd, l[i]);\n    }\n    return gcd;\n}", "unique_id": "MBCPP_45_9", "index": 428}
{"task_id": "MBCPP/46", "completion": "    set<int> unique_elements(data.begin(), data.end());\n    return unique_elements.size() == data.size();\n}", "unique_id": "MBCPP_46_8", "index": 437}
{"task_id": "MBCPP/47", "completion": "    long long factA = 1, factB = 1;\n    for (int i = 1; i <= a; ++i) {\n        factA *= i;\n    }\n    for (int i = 1; i <= b; ++i) {\n        factB *= i;\n    }\n    return (factB / factA) % 10;\n}", "unique_id": "MBCPP_47_5", "index": 444}
{"task_id": "MBCPP/48", "completion": "    for (int i = 0; i < 32; i += 2) {\n        n |= (1 << i);\n    }\n    return n;\n}", "unique_id": "MBCPP_48_10", "index": 459}
{"task_id": "MBCPP/49", "completion": "    vector<int> result;\n    for (const auto& row : nums) {\n        if (n < row.size()) {\n            result.push_back(row[n]);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_49_5", "index": 464}
{"task_id": "MBCPP/51", "completion": "    return (x == y) && (y == z);\n}", "unique_id": "MBCPP_51_7", "index": 476}
{"task_id": "MBCPP/52", "completion": "    return b * h;\n}", "unique_id": "MBCPP_52_2", "index": 481}
{"task_id": "MBCPP/53", "completion": "    if (str.front() == str.back()) {\n        return \"Equal\";\n    } else {\n        return \"Not Equal\";\n    }\n}", "unique_id": "MBCPP_53_7", "index": 496}
{"task_id": "MBCPP/54", "completion": "    if (myList.empty()) return myList;\n\n    int max_val = *max_element(myList.begin(), myList.end());\n    int min_val = *min_element(myList.begin(), myList.end());\n    int range = max_val - min_val + 1;\n\n    vector<int> count(range, 0);\n    vector<int> output(myList.size());\n\n    for (int num : myList) {\n        count[num - min_val]++;\n    }\n\n    for (int i = 1; i < range; i++) {\n        count[i] += count[i - 1];\n    }\n\n    for (int i = myList.size() - 1; i >= 0; i--) {\n        output[count[myList[i] - min_val] - 1] = myList[i];\n        count[myList[i] - min_val]--;\n    }\n\n    return output;\n}", "unique_id": "MBCPP_54_9", "index": 508}
{"task_id": "MBCPP/55", "completion": "    return a * pow(r, n - 1);\n}", "unique_id": "MBCPP_55_6", "index": 515}
{"task_id": "MBCPP/56", "completion": "    int original = n;\n    int reversed = 0;\n    \n    while (n > 0) {\n        reversed = reversed * 10 + n % 10;\n        n /= 10;\n    }\n    \n    return original == 2 * reversed - 1;\n}", "unique_id": "MBCPP_56_6", "index": 525}
{"task_id": "MBCPP/57", "completion": "    sort(arr.begin(), arr.end(), greater<int>());\n    int result = 0;\n    for (int i = 0; i < n; ++i) {\n        result = result * 10 + arr[i];\n    }\n    return result;\n}", "unique_id": "MBCPP_57_10", "index": 539}
{"task_id": "MBCPP/58", "completion": "    return (x ^ y) < 0;\n}", "unique_id": "MBCPP_58_6", "index": 545}
{"task_id": "MBCPP/59", "completion": "    return n * (3 * n - 2);\n}", "unique_id": "MBCPP_59_7", "index": 556}
{"task_id": "MBCPP/60", "completion": "    if (n == 0) return 0;\n    \n    int maxLen = 1;\n    int currLen = 1;\n    \n    for (int i = 1; i < n; ++i) {\n        if (abs(arr[i] - arr[i - 1]) == 1) {\n            currLen++;\n        } else {\n            currLen = 1;\n        }\n        maxLen = max(maxLen, currLen);\n    }\n    \n    return maxLen;\n}", "unique_id": "MBCPP_60_6", "index": 565}
{"task_id": "MBCPP/61", "completion": "    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        int sum = 0;\n        for (int j = i; j < n; ++j) {\n            sum += s[j] - '0';\n            if (sum == j - i + 1) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_61_5", "index": 574}
{"task_id": "MBCPP/62", "completion": "    return *min_element(xs.begin(), xs.end());\n}", "unique_id": "MBCPP_62_3", "index": 582}
{"task_id": "MBCPP/63", "completion": "    int max_diff = INT_MIN;\n    for (const auto& pair : testList) {\n        int diff = abs(pair[0] - pair[1]);\n        if (diff > max_diff) {\n            max_diff = diff;\n        }\n    }\n    return max_diff;\n}", "unique_id": "MBCPP_63_3", "index": 592}
{"task_id": "MBCPP/66", "completion": "    int count = 0;\n    for (int num : list) {\n        if (num > 0) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_66_8", "index": 607}
{"task_id": "MBCPP/68", "completion": "    bool increasing = true, decreasing = true;\n    for (int i = 1; i < a.size(); i++) {\n        if (a[i] > a[i-1]) decreasing = false;\n        if (a[i] < a[i-1]) increasing = false;\n    }\n    return increasing || decreasing;\n}", "unique_id": "MBCPP_68_3", "index": 612}
{"task_id": "MBCPP/69", "completion": "    if (s.empty()) return true;\n    if (l.size() < s.size()) return false;\n\n    for (size_t i = 0; i <= l.size() - s.size(); ++i) {\n        bool match = true;\n        for (size_t j = 0; j < s.size(); ++j) {\n            if (l[i + j] != s[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}", "unique_id": "MBCPP_69_1", "index": 620}
{"task_id": "MBCPP/70", "completion": "    for (const auto& tuple : input) {\n        if (tuple.size() != k) {\n            return \"All tuples do not have same length\";\n        }\n    }\n    return \"All tuples have same length\";\n}", "unique_id": "MBCPP_70_9", "index": 638}
{"task_id": "MBCPP/71", "completion": "    int gap = nums.size();\n    bool swapped = true;\n    \n    while (gap != 1 || swapped) {\n        gap = max(1, int(gap / 1.3));\n        swapped = false;\n        \n        for (int i = 0; i + gap < nums.size(); i++) {\n            if (nums[i] > nums[i + gap]) {\n                swap(nums[i], nums[i + gap]);\n                swapped = true;\n            }\n        }\n    }\n    \n    return nums;\n}", "unique_id": "MBCPP_71_7", "index": 646}
{"task_id": "MBCPP/72", "completion": "    if (n % 2 == 1) return true;\n    while (n % 4 == 0) n /= 4;\n    return n % 4 == 2 ? false : true;\n}", "unique_id": "MBCPP_72_2", "index": 651}
{"task_id": "MBCPP/73", "completion": "    regex re(\"[\\\\n*]+\");\n    sregex_token_iterator it(text.begin(), text.end(), re, -1);\n    sregex_token_iterator end;\n    vector<string> result;\n    while (it != end) {\n        result.push_back(*it++);\n    }\n    return result;\n}", "unique_id": "MBCPP_73_8", "index": 667}
{"task_id": "MBCPP/74", "completion": "    if(colors.size() != patterns.size())\n        return false;\n    \n    unordered_map<string, string> colorToPattern;\n    unordered_map<string, string> patternToColor;\n    \n    for(int i = 0; i < colors.size(); ++i) {\n        string color = colors[i];\n        string pattern = patterns[i];\n        \n        if(colorToPattern.find(color) == colorToPattern.end())\n            colorToPattern[color] = pattern;\n        if(patternToColor.find(pattern) == patternToColor.end())\n            patternToColor[pattern] = color;\n        \n        if(colorToPattern[color] != pattern || patternToColor[pattern] != color)\n            return false;\n    }\n    \n    return true;\n}", "unique_id": "MBCPP_74_5", "index": 674}
{"task_id": "MBCPP/75", "completion": "    vector<string> result;\n    for (const auto& tuple : testList) {\n        if (all_of(tuple.begin(), tuple.end(), [&](int num) { return num % k == 0; })) {\n            stringstream ss;\n            ss << \"(\";\n            for (size_t i = 0; i < tuple.size(); ++i) {\n                ss << tuple[i];\n                if (i < tuple.size() - 1) {\n                    ss << \", \";\n                }\n            }\n            ss << \")\";\n            result.push_back(ss.str());\n        }\n    }\n    string res = \"[\";\n    if (!result.empty()) {\n        res += result[0];\n        for (size_t i = 1; i < result.size(); ++i) {\n            res += \", \" + result[i];\n        }\n    }\n    res += \"]\";\n    return res;\n}", "unique_id": "MBCPP_75_9", "index": 688}
{"task_id": "MBCPP/76", "completion": "    int count = 0;\n    for (int i = 1; i <= min(m, n); ++i) {\n        count += (m - i + 1) * (n - i + 1);\n    }\n    return count;\n}", "unique_id": "MBCPP_76_9", "index": 698}
{"task_id": "MBCPP/77", "completion": "    int sum_even = 0, sum_odd = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 == 0)\n            sum_even += digit;\n        else\n            sum_odd += digit;\n        n /= 10;\n    }\n    return sum_even > sum_odd;\n}", "unique_id": "MBCPP_77_6", "index": 705}
{"task_id": "MBCPP/78", "completion": "    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        if (__builtin_popcount(i) % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_78_9", "index": 718}
{"task_id": "MBCPP/79", "completion": "    return s.length() % 2 != 0;\n}", "unique_id": "MBCPP_79_7", "index": 726}
{"task_id": "MBCPP/80", "completion": "    return (n * (n + 1) * (n + 2)) / 6.0;\n}", "unique_id": "MBCPP_80_8", "index": 737}
{"task_id": "MBCPP/81", "completion": "    vector<vector<int>> result;\n    int size1 = testTup1.size();\n    int size2 = testTup2.size();\n    for (int i = 0; i < size1; ++i) {\n        result.push_back({testTup1[i], testTup2[i % size2]});\n    }\n    return result;\n}", "unique_id": "MBCPP_81_1", "index": 740}
{"task_id": "MBCPP/82", "completion": "    return (4.0 / 3.0) * M_PI * pow(r, 3);\n}", "unique_id": "MBCPP_82_2", "index": 751}
{"task_id": "MBCPP/83", "completion": "    int sum = 0;\n    for(char c : strr) {\n        sum += c;\n    }\n    return string(1, sum);\n}", "unique_id": "MBCPP_83_5", "index": 764}
{"task_id": "MBCPP/84", "completion": "    if (n == 1 || n == 2) {\n        return 1;\n    }\n    vector<int> dp(n + 1);\n    dp[1] = dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]];\n    }\n    return dp[n];\n}", "unique_id": "MBCPP_84_2", "index": 771}
{"task_id": "MBCPP/85", "completion": "    return 4 * M_PI * r * r;\n}", "unique_id": "MBCPP_85_10", "index": 789}
{"task_id": "MBCPP/86", "completion": "    return 3 * n * (n - 1) + 1;\n}", "unique_id": "MBCPP_86_1", "index": 790}
{"task_id": "MBCPP/87", "completion": "    unordered_map<string, string> result = dict1;\n    for (const auto& pair : dict2) {\n        result[pair.first] = pair.second;\n    }\n    for (const auto& pair : dict3) {\n        result[pair.first] = pair.second;\n    }\n    return result;\n}", "unique_id": "MBCPP_87_4", "index": 803}
{"task_id": "MBCPP/88", "completion": "    unordered_map<int, int> frequency;\n    for (int num : list1) {\n        frequency[num]++;\n    }\n    return frequency;\n}", "unique_id": "MBCPP_88_2", "index": 811}
{"task_id": "MBCPP/89", "completion": "    return n - 1;\n}", "unique_id": "MBCPP_89_1", "index": 820}
{"task_id": "MBCPP/90", "completion": "    int maxLength = 0;\n    for (const string& word : list1) {\n        if (word.length() > maxLength) {\n            maxLength = word.length();\n        }\n    }\n    return maxLength;\n}", "unique_id": "MBCPP_90_4", "index": 833}
{"task_id": "MBCPP/91", "completion": "    for (const auto& str : str1) {\n        if (str.find(subStr) != string::npos) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_91_5", "index": 844}
{"task_id": "MBCPP/92", "completion": "    if (n.length() < 3) return false;\n    char first = n[0];\n    char second = n[1];\n    if (first == second) return false;\n    for (int i = 2; i < n.length(); ++i) {\n        if (i % 2 == 0 && n[i] != first) return false;\n        if (i % 2 != 0 && n[i] != second) return false;\n    }\n    return true;\n}", "unique_id": "MBCPP_92_7", "index": 856}
{"task_id": "MBCPP/93", "completion": "    if (b == 0)\n        return 1;\n    return a * power(a, b - 1);\n}", "unique_id": "MBCPP_93_9", "index": 868}
{"task_id": "MBCPP/95", "completion": "    int minLength = INT_MAX;\n    for (const auto& sublist : lst) {\n        minLength = min(minLength, static_cast<int>(sublist.size()));\n    }\n    return minLength;\n}", "unique_id": "MBCPP_95_5", "index": 874}
{"task_id": "MBCPP/96", "completion": "    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_96_6", "index": 885}
{"task_id": "MBCPP/97", "completion": "    unordered_map<int, int> freqMap;\n    for (const auto& sublist : list1) {\n        for (int num : sublist) {\n            freqMap[num]++;\n        }\n    }\n    return freqMap;\n}", "unique_id": "MBCPP_97_3", "index": 892}
{"task_id": "MBCPP/98", "completion": "    if (numbers.empty()) return 0;\n    double product = 1;\n    for (int num : numbers) {\n        product *= num;\n    }\n    return product / numbers.size();\n}", "unique_id": "MBCPP_98_7", "index": 906}
{"task_id": "MBCPP/99", "completion": "    string binary = \"\";\n    while (n > 0) {\n        binary = to_string(n % 2) + binary;\n        n = n / 2;\n    }\n    return binary;\n}", "unique_id": "MBCPP_99_9", "index": 918}
{"task_id": "MBCPP/100", "completion": "    if (num < 9)\n        return num + 1;\n    string s = to_string(num);\n    int n = s.size();\n    string left = s.substr(0, (n + 1) / 2);\n    string nextLeft = to_string(stoll(left) + 1);\n    string palindrome = nextLeft + string(nextLeft.rbegin() + (n % 2), nextLeft.rend());\n    if (stoll(palindrome) > num)\n        return stoll(palindrome);\n    nextLeft = to_string(stoll(left));\n    palindrome = nextLeft + string(nextLeft.rbegin() + (n % 2), nextLeft.rend());\n    return stoll(palindrome);\n}", "unique_id": "MBCPP_100_3", "index": 922}
{"task_id": "MBCPP/101", "completion": "    sort(arr.begin(), arr.end());\n    return arr[k-1];\n}", "unique_id": "MBCPP_101_10", "index": 939}
{"task_id": "MBCPP/102", "completion": "    string result;\n    bool toUpper = true;\n    for (char ch : word) {\n        if (ch == '_') {\n            toUpper = true;\n        } else {\n            if (toUpper) {\n                result += toupper(ch);\n                toUpper = false;\n            } else {\n                result += ch;\n            }\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_102_8", "index": 947}
{"task_id": "MBCPP/103", "completion": "    if (m >= n || m < 0) \n        return 0;\n    if (m == 0) \n        return 1;\n    return (n - m) * eulerianNum(n - 1, m - 1) + (m + 1) * eulerianNum(n - 1, m);\n}", "unique_id": "MBCPP_103_3", "index": 952}
{"task_id": "MBCPP/104", "completion": "    for(auto& sublist : inputList) {\n        sort(sublist.begin(), sublist.end(), [](const string& a, const string& b) {\n            return a < b;\n        });\n    }\n    return inputList;\n}", "unique_id": "MBCPP_104_4", "index": 963}
{"task_id": "MBCPP/105", "completion": "    return std::count(lst.begin(), lst.end(), true);\n}", "unique_id": "MBCPP_105_9", "index": 978}
{"task_id": "MBCPP/106", "completion": "    testTup.insert(testTup.end(), testList.begin(), testList.end());\n    return testTup;\n}", "unique_id": "MBCPP_106_3", "index": 982}
{"task_id": "MBCPP/107", "completion": "    int count = 0;\n    for (int i = l; i <= r; ++i) {\n        if (i >= 10 && i <= 15) {\n            ++count;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_107_4", "index": 993}
{"task_id": "MBCPP/108", "completion": "    vector<int> merged;\n    merged.insert(merged.end(), num1.begin(), num1.end());\n    merged.insert(merged.end(), num2.begin(), num2.end());\n    merged.insert(merged.end(), num3.begin(), num3.end());\n    sort(merged.begin(), merged.end());\n    return merged;\n}", "unique_id": "MBCPP_108_9", "index": 1008}
{"task_id": "MBCPP/109", "completion": "    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((s[n - 1] - '0') % 2 != 0) {\n            count++;\n        }\n        rotate(s.begin(), s.begin() + 1, s.end());\n    }\n    return count;\n}", "unique_id": "MBCPP_109_7", "index": 1016}
{"task_id": "MBCPP/110", "completion": "    vector<vector<int>> result;\n    sort(testList.begin(), testList.end());\n    \n    if (!testList.empty() && strtVal < testList[0][0]) {\n        result.push_back({strtVal, testList[0][0]});\n    }\n    \n    for (int i = 0; i < testList.size(); ++i) {\n        if (i == 0 && strtVal > testList[i][0]) {\n            result.push_back({testList[i][1], stopVal});\n        }\n        if (i > 0) {\n            if (testList[i - 1][1] < testList[i][0]) {\n                result.push_back({testList[i - 1][1], testList[i][0]});\n            }\n            if (i == testList.size() - 1 && testList[i][1] < stopVal) {\n                result.push_back({testList[i][1], stopVal});\n            }\n        }\n    }\n    \n    if (testList.empty() || testList.back()[1] < stopVal) {\n        result.push_back({strtVal, stopVal});\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_110_6", "index": 1025}
{"task_id": "MBCPP/111", "completion": "    unordered_map<int, int> frequency;\n    vector<int> result;\n    \n    for (const auto& list : nestedlist) {\n        unordered_set<int> unique_elements(list.begin(), list.end());\n        for (int element : unique_elements) {\n            frequency[element]++;\n        }\n    }\n    \n    for (const auto& [element, count] : frequency) {\n        if (count == nestedlist.size()) {\n            result.push_back(element);\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_111_5", "index": 1034}
{"task_id": "MBCPP/112", "completion": "    return 2 * (diameter + height);\n}", "unique_id": "MBCPP_112_3", "index": 1042}
{"task_id": "MBCPP/113", "completion": "    for (char c : text) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_113_7", "index": 1056}
{"task_id": "MBCPP/114", "completion": "    unordered_map<string, int> freqMap;\n    vector<vector<int>> uniqueTuples;\n\n    for (const auto& tuple : testList) {\n        stringstream ss;\n        for (int num : tuple) {\n            ss << num << \",\";\n        }\n        string key = ss.str();\n        freqMap[key]++;\n    }\n\n    for (const auto& tuple : testList) {\n        stringstream ss;\n        for (int num : tuple) {\n            ss << num << \",\";\n        }\n        string key = ss.str();\n        if (freqMap[key] != 0) {\n            vector<int> newTuple = tuple;\n            newTuple.push_back(freqMap[key]);\n            uniqueTuples.push_back(newTuple);\n            freqMap[key] = 0; // Mark as visited\n        }\n    }\n\n    stringstream result;\n    result << \"[\";\n    for (size_t i = 0; i < uniqueTuples.size(); ++i) {\n        result << \"(\";\n        for (size_t j = 0; j < uniqueTuples[i].size(); ++j) {\n            result << uniqueTuples[i][j];\n            if (j != uniqueTuples[i].size() - 1) {\n                result << \", \";\n            }\n        }\n        result << \")\";\n        if (i != uniqueTuples.size() - 1) {\n            result << \", \";\n        }\n    }\n    result << \"]\";\n    return result.str();\n}", "unique_id": "MBCPP_114_3", "index": 1062}
{"task_id": "MBCPP/116", "completion": "    int result = 0;\n    for (int num : nums) {\n        result = result * 10 + num;\n    }\n    return result;\n}", "unique_id": "MBCPP_116_8", "index": 1077}
{"task_id": "MBCPP/117", "completion": "    string result = \"[\";\n    for (int i = 0; i < testList.size(); ++i) {\n        result += \"(\";\n        for (int j = 0; j < testList[i].size(); ++j) {\n            result += to_string(stof(testList[i][j]));\n            if (j != testList[i].size() - 1) {\n                result += \", \";\n            }\n        }\n        result += \")\";\n        if (i != testList.size() - 1) {\n            result += \", \";\n        }\n    }\n    result += \"]\";\n    return result;\n}", "unique_id": "MBCPP_117_1", "index": 1080}
{"task_id": "MBCPP/118", "completion": "    vector<string> result;\n    stringstream ss(str);\n    string word;\n    while (ss >> word) {\n        result.push_back(word);\n    }\n    return result;\n}", "unique_id": "MBCPP_118_8", "index": 1097}
{"task_id": "MBCPP/119", "completion": "    int low = 0, high = n - 1;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (mid % 2 == 1) mid--; // Ensure mid is even\n        \n        if (arr[mid] == arr[mid + 1]) {\n            low = mid + 2;\n        } else {\n            high = mid;\n        }\n    }\n    return arr[low];\n}", "unique_id": "MBCPP_119_2", "index": 1101}
{"task_id": "MBCPP/120", "completion": "    int max_product = INT_MIN;\n    for (const auto& tuple : list1) {\n        int product = tuple[0] * tuple[1];\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n    return max_product;\n}", "unique_id": "MBCPP_120_8", "index": 1117}
{"task_id": "MBCPP/121", "completion": "    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (a[i] + a[j] + a[k] == sum) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_121_9", "index": 1128}
{"task_id": "MBCPP/122", "completion": "    return 30 + (n - 1) * 33;\n}", "unique_id": "MBCPP_122_5", "index": 1134}
{"task_id": "MBCPP/123", "completion": "    auto sumOfDivisors = [](int n) {\n        int sum = 1;\n        for (int i = 2; i <= sqrt(n); i++) {\n            if (n % i == 0) {\n                if (i == (n / i))\n                    sum += i;\n                else\n                    sum += i + (n / i);\n            }\n        }\n        return sum;\n    };\n\n    int totalSum = 0;\n    for (int i = 2; i < limit; i++) {\n        int a = sumOfDivisors(i);\n        if (a > i && a < limit) {\n            int b = sumOfDivisors(a);\n            if (b == i) {\n                totalSum += i + a;\n            }\n        }\n    }\n    return totalSum;\n}", "unique_id": "MBCPP_123_10", "index": 1149}
{"task_id": "MBCPP/125", "completion": "    int max_diff = 0;\n    int current_diff = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (str[i] == '0') {\n            current_diff++;\n        } else {\n            current_diff--;\n        }\n\n        if (current_diff < 0) {\n            current_diff = 0;\n        }\n\n        max_diff = max(max_diff, current_diff);\n    }\n\n    return max_diff == 0 ? -1 : max_diff;\n}", "unique_id": "MBCPP_125_3", "index": 1152}
{"task_id": "MBCPP/126", "completion": "    int gcd = __gcd(a, b);\n    int result = 0;\n    for (int i = 1; i <= gcd; ++i) {\n        if (gcd % i == 0) {\n            result += i;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_126_7", "index": 1166}
{"task_id": "MBCPP/127", "completion": "    int result = 0;\n    while (y > 0) {\n        if (y & 1) {\n            result += x;\n        }\n        x <<= 1;\n        y >>= 1;\n    }\n    return result;\n}", "unique_id": "MBCPP_127_8", "index": 1177}
{"task_id": "MBCPP/128", "completion": "    vector<string> result;\n    stringstream ss(str);\n    string word;\n    \n    while (ss >> word) {\n        if (word.length() > n) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_128_8", "index": 1187}
{"task_id": "MBCPP/129", "completion": "    int n = myMatrix.size();\n    if (n == 0 || myMatrix[0].size() != n) return false;\n    \n    int magicSum = n * (n * n + 1) / 2;\n    \n    for (int i = 0; i < n; ++i) {\n        int rowSum = 0, colSum = 0;\n        for (int j = 0; j < n; ++j) {\n            rowSum += myMatrix[i][j];\n            colSum += myMatrix[j][i];\n        }\n        if (rowSum != magicSum || colSum != magicSum) return false;\n    }\n    \n    int diagSum1 = 0, diagSum2 = 0;\n    for (int i = 0; i < n; ++i) {\n        diagSum1 += myMatrix[i][i];\n        diagSum2 += myMatrix[i][n - i - 1];\n    }\n    \n    return diagSum1 == magicSum && diagSum2 == magicSum;\n}", "unique_id": "MBCPP_129_4", "index": 1193}
{"task_id": "MBCPP/130", "completion": "    unordered_map<int, int> frequency;\n    for (int num : nums) {\n        frequency[num]++;\n    }\n    \n    int maxFreq = 0;\n    int maxItem = nums[0];\n    for (const auto& pair : frequency) {\n        if (pair.second > maxFreq) {\n            maxFreq = pair.second;\n            maxItem = pair.first;\n        }\n    }\n    \n    return {maxItem, maxFreq};\n}", "unique_id": "MBCPP_130_4", "index": 1203}
{"task_id": "MBCPP/131", "completion": "    int left = 0, right = str1.size() - 1;\n    string vowels = \"aeiouAEIOU\";\n    while (left < right) {\n        if (vowels.find(str1[left]) == string::npos) {\n            left++;\n            continue;\n        }\n        if (vowels.find(str1[right]) == string::npos) {\n            right--;\n            continue;\n        }\n        swap(str1[left], str1[right]);\n        left++;\n        right--;\n    }\n    return str1;\n}", "unique_id": "MBCPP_131_10", "index": 1219}
{"task_id": "MBCPP/132", "completion": "    string result = \"\";\n    for (const auto& s : tup1) {\n        result += s;\n    }\n    return result;\n}", "unique_id": "MBCPP_132_7", "index": 1226}
{"task_id": "MBCPP/133", "completion": "    return accumulate(nums.begin(), nums.end(), 0, [](int acc, int num) {\n        return num < 0 ? acc + num : acc;\n    });\n}", "unique_id": "MBCPP_133_5", "index": 1234}
{"task_id": "MBCPP/134", "completion": "    if (p % 2 == 1) {\n        arr[n-1] += p;\n    }\n    return (arr[n-1] % 2 == 0) ? \"EVEN\" : \"ODD\";\n}", "unique_id": "MBCPP_134_1", "index": 1240}
{"task_id": "MBCPP/135", "completion": "    return n * (2 * n - 1);\n}", "unique_id": "MBCPP_135_1", "index": 1250}
{"task_id": "MBCPP/136", "completion": "    double bill = 0;\n    if (units <= 50) {\n        bill = units * 2.60;\n    } else if (units <= 100) {\n        bill = 50 * 2.60 + (units - 50) * 3.25;\n    } else if (units <= 200) {\n        bill = 50 * 2.60 + 50 * 3.25 + (units - 100) * 5.26;\n    } else {\n        bill = 50 * 2.60 + 50 * 3.25 + 100 * 5.26 + (units - 200) * 7.75;\n    }\n    return bill;\n}", "unique_id": "MBCPP_136_2", "index": 1261}
{"task_id": "MBCPP/137", "completion": "    int zeroes = count(nums.begin(), nums.end(), 0);\n    return static_cast<double>(zeroes) / nums.size();\n}", "unique_id": "MBCPP_137_9", "index": 1278}
{"task_id": "MBCPP/138", "completion": "    while (n > 0) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            n--;\n        }\n    }\n    return (n == 0);\n}", "unique_id": "MBCPP_138_10", "index": 1289}
{"task_id": "MBCPP/139", "completion": "    return 2 * M_PI * r;\n}", "unique_id": "MBCPP_139_6", "index": 1295}
{"task_id": "MBCPP/140", "completion": "    set<int> resultSet;\n    for (const auto& sublist : testList) {\n        resultSet.insert(sublist.begin(), sublist.end());\n    }\n    return vector<int>(resultSet.begin(), resultSet.end());\n}", "unique_id": "MBCPP_140_3", "index": 1302}
{"task_id": "MBCPP/141", "completion": "    auto flip = [](vector<int>& arr, int k) {\n        reverse(arr.begin(), arr.begin() + k + 1);\n    };\n    \n    for (int i = nums.size(); i > 1; --i) {\n        int max_idx = max_element(nums.begin(), nums.begin() + i) - nums.begin();\n        if (max_idx == i - 1) continue;\n        if (max_idx != 0) {\n            flip(nums, max_idx);\n        }\n        flip(nums, i - 1);\n    }\n    return nums;\n}", "unique_id": "MBCPP_141_2", "index": 1311}
{"task_id": "MBCPP/142", "completion": "    int count = 0;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            ++count;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_142_10", "index": 1329}
{"task_id": "MBCPP/144", "completion": "    sort(arr.begin(), arr.end());\n    \n    int sum = 0;\n    int prefix_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        sum += (arr[i] * i - prefix_sum);\n        prefix_sum += arr[i];\n    }\n\n    return 2 * sum;\n}", "unique_id": "MBCPP_144_5", "index": 1334}
{"task_id": "MBCPP/145", "completion": "    if (n < 2) return 0;\n    int maxElement = *max_element(arr.begin(), arr.end());\n    int minElement = *min_element(arr.begin(), arr.end());\n    return maxElement - minElement;\n}", "unique_id": "MBCPP_145_3", "index": 1342}
{"task_id": "MBCPP/146", "completion": "    if (str1.empty()) return 0;\n    return str1[0];\n}", "unique_id": "MBCPP_146_1", "index": 1350}
{"task_id": "MBCPP/147", "completion": "    for (int i = m - 1; i >= 0; i--) {\n        for (int j = 0; j <= i; j++) {\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1]);\n        }\n    }\n    return tri[0][0];\n}", "unique_id": "MBCPP_147_7", "index": 1366}
{"task_id": "MBCPP/148", "completion": "    string str = to_string(n);\n    int max_sum = 0;\n    for (int i = 1; i < str.length(); ++i) {\n        int part1 = stoi(str.substr(0, i));\n        int part2 = stoi(str.substr(i));\n        int sum = part1 + part2;\n        max_sum = max(max_sum, sum);\n    }\n    return max_sum;\n}", "unique_id": "MBCPP_148_3", "index": 1372}
{"task_id": "MBCPP/149", "completion": "    vector<int> dp(n, 1);\n    int maxLength = 1;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (abs(arr[i] - arr[j]) == 1) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        maxLength = max(maxLength, dp[i]);\n    }\n\n    return maxLength;\n}", "unique_id": "MBCPP_149_3", "index": 1382}
{"task_id": "MBCPP/150", "completion": "    if (c == 0)\n        return a == b;\n    return (b - a) % c == 0 && (b - a) / c >= 0;\n}", "unique_id": "MBCPP_150_6", "index": 1395}
{"task_id": "MBCPP/151", "completion": "    return __gcd(x, y) == 1;\n}", "unique_id": "MBCPP_151_3", "index": 1402}
{"task_id": "MBCPP/152", "completion": "    if (x.size() <= 1) {\n        return x;\n    }\n    int mid = x.size() / 2;\n    vector<int> left(x.begin(), x.begin() + mid);\n    vector<int> right(x.begin() + mid, x.end());\n\n    left = mergeSort(left);\n    right = mergeSort(right);\n\n    vector<int> result;\n    auto it1 = left.begin();\n    auto it2 = right.begin();\n\n    while (it1 != left.end() && it2 != right.end()) {\n        if (*it1 < *it2) {\n            result.push_back(*it1);\n            it1++;\n        } else {\n            result.push_back(*it2);\n            it2++;\n        }\n    }\n\n    while (it1 != left.end()) {\n        result.push_back(*it1);\n        it1++;\n    }\n\n    while (it2 != right.end()) {\n        result.push_back(*it2);\n        it2++;\n    }\n\n    return result;\n}", "unique_id": "MBCPP_152_3", "index": 1412}
{"task_id": "MBCPP/153", "completion": "    double x = -b / (2.0 * a);\n    double y = (a * x * x) + (b * x) + c;\n    return {x, y};\n}", "unique_id": "MBCPP_153_2", "index": 1421}
{"task_id": "MBCPP/154", "completion": "    vector<int> result;\n    for (const auto& row : nums) {\n        if (n < row.size()) {\n            result.push_back(row[n]);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_154_2", "index": 1431}
{"task_id": "MBCPP/155", "completion": "    int mask = 0xAAAAAAAA; // 32-bit mask with all even bits set\n    return n ^ mask;\n}", "unique_id": "MBCPP_155_2", "index": 1441}
{"task_id": "MBCPP/156", "completion": "    vector<vector<int>> result;\n    for (const auto& vec : tupleStr) {\n        vector<int> intVec;\n        for (const auto& str : vec) {\n            intVec.push_back(stoi(str));\n        }\n        result.push_back(intVec);\n    }\n    return result;\n}", "unique_id": "MBCPP_156_10", "index": 1459}
{"task_id": "MBCPP/158", "completion": "    int max_val = *max_element(arr.begin(), arr.end());\n    int min_val = *min_element(arr.begin(), arr.end());\n\n    if ((max_val - min_val) % k != 0) {\n        return -1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if ((arr[i] - min_val) % k == 0) {\n            count += (arr[i] - min_val) / k;\n        } else {\n            return -1;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_158_4", "index": 1463}
{"task_id": "MBCPP/159", "completion": "    if ((month == \"December\" && days >= 21) || month == \"January\" || month == \"February\" || (month == \"March\" && days < 20))\n        return \"winter\";\n    else if ((month == \"March\" && days >= 20) || month == \"April\" || month == \"May\" || (month == \"June\" && days < 21))\n        return \"spring\";\n    else if ((month == \"June\" && days >= 21) || month == \"July\" || month == \"August\" || (month == \"September\" && days < 22))\n        return \"summer\";\n    else if ((month == \"September\" && days >= 22) || month == \"October\" || month == \"November\" || (month == \"December\" && days < 21))\n        return \"autumn\";\n    return \"\";\n}", "unique_id": "MBCPP_159_9", "index": 1478}
{"task_id": "MBCPP/161", "completion": "    unordered_set<int> set2(list2.begin(), list2.end());\n    vector<int> result;\n    for (int num : list1) {\n        if (set2.find(num) == set2.end()) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_161_3", "index": 1482}
{"task_id": "MBCPP/162", "completion": "    int sum = 0;\n    for (int i = n; i > 0; i -= 2) {\n        sum += i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_162_6", "index": 1495}
{"task_id": "MBCPP/163", "completion": "    return (s * l * l) / (4 * tan(M_PI / s));\n}", "unique_id": "MBCPP_163_1", "index": 1500}
{"task_id": "MBCPP/164", "completion": "    auto sum_of_divisors = [](int n) {\n        int sum = 0;\n        for (int i = 1; i <= n / 2; ++i) {\n            if (n % i == 0) {\n                sum += i;\n            }\n        }\n        return sum + n;\n    };\n\n    return sum_of_divisors(num1) == sum_of_divisors(num2);\n}", "unique_id": "MBCPP_164_2", "index": 1511}
{"task_id": "MBCPP/165", "completion": "    int count = 0;\n    for (int i = 0; i < str1.length(); i++) {\n        if (tolower(str1[i]) - 'a' == i) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_165_2", "index": 1521}
{"task_id": "MBCPP/166", "completion": "    int even_count = 0;\n    int odd_count = 0;\n\n    for (int num : a) {\n        if (num % 2 == 0)\n            even_count++;\n        else\n            odd_count++;\n    }\n\n    return even_count * (even_count - 1) / 2 + odd_count * (odd_count - 1) / 2;\n}", "unique_id": "MBCPP_166_6", "index": 1535}
{"task_id": "MBCPP/167", "completion": "    if (n <= 0)\n        return 1;\n    n--;\n    n |= n >> 1;\n    n |= n >> 2;\n    n |= n >> 4;\n    n |= n >> 8;\n    n |= n >> 16;\n    return n + 1;\n}", "unique_id": "MBCPP_167_3", "index": 1542}
{"task_id": "MBCPP/168", "completion": "    return count(a.begin(), a.end(), x);\n}", "unique_id": "MBCPP_168_8", "index": 1557}
{"task_id": "MBCPP/169", "completion": "    if (n == 0) return 0;\n    if (n == 1) return 1;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; ++i) {\n        c = 2 * b + a;\n        a = b;\n        b = c;\n    }\n    return b;\n}", "unique_id": "MBCPP_169_3", "index": 1562}
{"task_id": "MBCPP/170", "completion": "    int sum = 0;\n    for (int i = m; i <= n; ++i) {\n        sum += list1[i];\n    }\n    return sum;\n}", "unique_id": "MBCPP_170_8", "index": 1577}
{"task_id": "MBCPP/171", "completion": "    return 5 * a;\n}", "unique_id": "MBCPP_171_3", "index": 1582}
{"task_id": "MBCPP/172", "completion": "    string target = \"std\";\n    int count = 0;\n    size_t pos = s.find(target);\n    while (pos != string::npos) {\n        count++;\n        pos = s.find(target, pos + target.length());\n    }\n    return count;\n}", "unique_id": "MBCPP_172_4", "index": 1593}
{"task_id": "MBCPP/173", "completion": "    string result;\n    for (char c : text) {\n        if (isalnum(c)) {\n            result += c;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_173_10", "index": 1609}
{"task_id": "MBCPP/175", "completion": "    stack<char> s;\n    for (char ch : str1) {\n        if (ch == '(' || ch == '{' || ch == '[') {\n            s.push(ch);\n        } else {\n            if (s.empty()) return false;\n            char top = s.top();\n            s.pop();\n            if ((ch == ')' && top != '(') || \n                (ch == '}' && top != '{') || \n                (ch == ']' && top != '[')) {\n                return false;\n            }\n        }\n    }\n    return s.empty();\n}", "unique_id": "MBCPP_175_8", "index": 1617}
{"task_id": "MBCPP/176", "completion": "    return a + b + c;\n}", "unique_id": "MBCPP_176_1", "index": 1620}
{"task_id": "MBCPP/177", "completion": "    for (int i = l; i <= r; ++i) {\n        for (int j = i + 1; j <= r; ++j) {\n            if (lcm(i, j) <= r) {\n                return {i, j};\n            }\n        }\n    }\n    return {};\n}", "unique_id": "MBCPP_177_8", "index": 1637}
{"task_id": "MBCPP/178", "completion": "    for (const string& pattern : patterns) {\n        if (text.find(pattern) != string::npos) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}", "unique_id": "MBCPP_178_8", "index": 1647}
{"task_id": "MBCPP/179", "completion": "    vector<int> terms;\n    int n = x;\n    while (n > 0) {\n        terms.insert(terms.begin(), n % 10);\n        n /= 10;\n    }\n\n    int numDigits = terms.size();\n    int sum = 0, i = numDigits;\n\n    while (sum < x) {\n        sum = 0;\n        for (int j = 0; j < numDigits; ++j) {\n            sum += terms[i - numDigits + j];\n        }\n        terms.push_back(sum);\n        ++i;\n    }\n\n    return (sum == x);\n}", "unique_id": "MBCPP_179_9", "index": 1658}
{"task_id": "MBCPP/181", "completion": "    if (n == 0) return \"\";\n    string prefix = arr[0];\n    for (int i = 1; i < n; i++) {\n        while (arr[i].find(prefix) != 0) {\n            prefix = prefix.substr(0, prefix.length() - 1);\n            if (prefix.empty()) return \"\";\n        }\n    }\n    return prefix;\n}", "unique_id": "MBCPP_181_7", "index": 1666}
{"task_id": "MBCPP/183", "completion": "    unordered_set<int> elements;\n    unordered_set<int> pairs;\n\n    for (int i = 0; i < n; i++) {\n        if (elements.find(arr[i] - k) != elements.end()) {\n            pairs.insert(arr[i] - k);\n        }\n        if (elements.find(arr[i] + k) != elements.end()) {\n            pairs.insert(arr[i]);\n        }\n        elements.insert(arr[i]);\n    }\n\n    return pairs.size();\n}", "unique_id": "MBCPP_183_8", "index": 1677}
{"task_id": "MBCPP/184", "completion": "    for (int value : list) {\n        if (value > num) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_184_8", "index": 1687}
{"task_id": "MBCPP/185", "completion": "    double h = -b / (2.0 * a);\n    double k = c - (b * b) / (4.0 * a);\n    double p = 1.0 / (4.0 * a);\n    return {h, k + p};\n}", "unique_id": "MBCPP_185_9", "index": 1698}
{"task_id": "MBCPP/186", "completion": "    for (const auto& pattern : patterns) {\n        regex re(pattern);\n        if (regex_search(text, re)) {\n            return \"Matched!\";\n        }\n    }\n    return \"Not Matched!\";\n}", "unique_id": "MBCPP_186_4", "index": 1703}
{"task_id": "MBCPP/187", "completion": "    vector<vector<int>> dp(m + 1, n + 1, 0);\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (x[i - 1] == y[j - 1])\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    \n    return dp[m][n];\n}", "unique_id": "MBCPP_187_3", "index": 1712}
{"task_id": "MBCPP/188", "completion": "    for (int i = 0; i * i <= n; ++i) {\n        for (int j = 0; j * j <= n; ++j) {\n            if (i * i * j * j == n) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_188_4", "index": 1723}
{"task_id": "MBCPP/189", "completion": "    for (int i = 0; i < n; i++) {\n        while (arr[i] > 0 && arr[i] <= n && arr[arr[i] - 1] != arr[i]) {\n            swap(arr[i], arr[arr[i] - 1]);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (arr[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}", "unique_id": "MBCPP_189_9", "index": 1738}
{"task_id": "MBCPP/190", "completion": "    int minX = min(x1, x2);\n    int maxX = max(x1, x2);\n    int minY = min(y1, y2);\n    int maxY = max(y1, y2);\n    \n    int count = 0;\n    for (int i = minX + 1; i < maxX; ++i) {\n        for (int j = minY + 1; j < maxY; ++j) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_190_5", "index": 1744}
{"task_id": "MBCPP/191", "completion": "    string monthsWith30Days[] = {\"April\", \"June\", \"September\", \"November\"};\n    for (const string &month : monthsWith30Days) {\n        if (month == monthname3) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_191_7", "index": 1756}
{"task_id": "MBCPP/192", "completion": "    bool hasLetter = false;\n    bool hasNumber = false;\n    for (char c : str) {\n        if (isalpha(c)) {\n            hasLetter = true;\n        }\n        if (isdigit(c)) {\n            hasNumber = true;\n        }\n        if (hasLetter && hasNumber) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_192_7", "index": 1766}
{"task_id": "MBCPP/193", "completion": "    set<int> uniqueElements(testTup.begin(), testTup.end());\n    return vector<int>(uniqueElements.begin(), uniqueElements.end());\n}", "unique_id": "MBCPP_193_6", "index": 1775}
{"task_id": "MBCPP/194", "completion": "    int decimal = 0, base = 1;\n    while (n > 0) {\n        int last_digit = n % 10;\n        n = n / 10;\n        decimal += last_digit * base;\n        base = base * 8;\n    }\n    return decimal;\n}", "unique_id": "MBCPP_194_5", "index": 1784}
{"task_id": "MBCPP/195", "completion": "    int low = 0, high = n - 1, result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == x) {\n            result = mid;\n            high = mid - 1;\n        } else if (arr[mid] < x) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_195_9", "index": 1798}
{"task_id": "MBCPP/196", "completion": "    vector<vector<int>> result;\n    for (const auto& tuple : testList) {\n        if (tuple.size() != k) {\n            result.push_back(tuple);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_196_9", "index": 1808}
{"task_id": "MBCPP/197", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(pow(testTup1[i], testTup2[i]));\n    }\n    return result;\n}", "unique_id": "MBCPP_197_10", "index": 1819}
{"task_id": "MBCPP/198", "completion": "    return 3 * sqrt(3) / 2 * a * b;\n}", "unique_id": "MBCPP_198_6", "index": 1825}
{"task_id": "MBCPP/199", "completion": "    int res = 1;\n    while (res <= n)\n        res <<= 1;\n    return res >> 1;\n}", "unique_id": "MBCPP_199_10", "index": 1839}
{"task_id": "MBCPP/200", "completion": "    vector<int> positions;\n    if (list1.empty()) return positions;\n    \n    int max_val = *max_element(list1.begin(), list1.end());\n    \n    for (int i = 0; i < list1.size(); ++i) {\n        if (list1[i] == max_val) {\n            positions.push_back(i);\n        }\n    }\n    \n    return positions;\n}", "unique_id": "MBCPP_200_4", "index": 1843}
{"task_id": "MBCPP/201", "completion": "    if (lst.empty()) return true;\n    for (const auto& item : lst) {\n        if (item != lst[0]) return false;\n    }\n    return true;\n}", "unique_id": "MBCPP_201_7", "index": 1856}
{"task_id": "MBCPP/202", "completion": "    string result = \"\";\n    for (int i = 0; i < str1.length(); i++) {\n        if (i % 2 == 0) {\n            result += str1[i];\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_202_9", "index": 1868}
{"task_id": "MBCPP/203", "completion": "    int x = n1 ^ n2;\n    int distance = 0;\n    while (x > 0) {\n        distance += x & 1;\n        x >>= 1;\n    }\n    return distance;\n}", "unique_id": "MBCPP_203_10", "index": 1879}
{"task_id": "MBCPP/204", "completion": "    return std::count(s.begin(), s.end(), c[0]);\n}", "unique_id": "MBCPP_204_10", "index": 1889}
{"task_id": "MBCPP/205", "completion": "    vector<int> result;\n    for (int i = 0; i < testTup.size(); ++i) {\n        result.push_back(-(testTup[i] + 1));\n    }\n    return result;\n}", "unique_id": "MBCPP_205_4", "index": 1893}
{"task_id": "MBCPP/206", "completion": "    vector<string> result;\n    for (size_t i = 0; i < testTup.size() - 1; ++i) {\n        result.push_back(testTup[i] + testTup[i + 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_206_5", "index": 1904}
{"task_id": "MBCPP/207", "completion": "    int n = str.size();\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (str[i - 1] == str[j - 1] && i != j)\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            else\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n\n    return dp[n][n];\n}", "unique_id": "MBCPP_207_2", "index": 1911}
{"task_id": "MBCPP/208", "completion": "    regex decimal_regex(\"^\\\\d+\\\\.\\\\d{2}$\");\n    return regex_match(num, decimal_regex);\n}", "unique_id": "MBCPP_208_7", "index": 1926}
{"task_id": "MBCPP/209", "completion": "    pop_heap(heap.begin(), heap.end(), greater<int>());\n    heap.back() = a;\n    push_heap(heap.begin(), heap.end(), greater<int>());\n    return heap;\n}", "unique_id": "MBCPP_209_10", "index": 1939}
{"task_id": "MBCPP/210", "completion": "    regex pattern(\"^[a-zA-Z0-9]+$\");\n    return regex_match(str, pattern);\n}", "unique_id": "MBCPP_210_9", "index": 1948}
{"task_id": "MBCPP/211", "completion": "    int count = 0;\n    for (int i = 0; i <= n; ++i) {\n        if ((i & 1) && (i & (1 << n))) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_211_4", "index": 1953}
{"task_id": "MBCPP/212", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += i * i * i * i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_212_1", "index": 1960}
{"task_id": "MBCPP/213", "completion": "    vector<string> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] + testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_213_5", "index": 1974}
{"task_id": "MBCPP/214", "completion": "    return radian * (180.0 / M_PI);\n}", "unique_id": "MBCPP_214_7", "index": 1986}
{"task_id": "MBCPP/217", "completion": "    unordered_set<char> seen;\n    for (char c : str) {\n        if (seen.count(c))\n            return string(1, c);\n        seen.insert(c);\n    }\n    return string(1, '\\0');\n}", "unique_id": "MBCPP_217_1", "index": 1990}
{"task_id": "MBCPP/218", "completion": "    return abs(a - b);\n}", "unique_id": "MBCPP_218_1", "index": 2000}
{"task_id": "MBCPP/219", "completion": "    sort(testTup.begin(), testTup.end());\n    vector<int> result;\n    for (int i = 0; i < k; ++i) {\n        result.push_back(testTup[i]);\n    }\n    for (int i = testTup.size() - k; i < testTup.size(); ++i) {\n        result.push_back(testTup[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_219_1", "index": 2010}
{"task_id": "MBCPP/220", "completion": "    int count = 0;\n    for (char& c : text) {\n        if (count >= n) break;\n        if (c == ' ' || c == ',' || c == '.') {\n            c = ':';\n            count++;\n        }\n    }\n    return text;\n}", "unique_id": "MBCPP_220_6", "index": 2025}
{"task_id": "MBCPP/221", "completion": "    for (int num : nums) {\n        if (num % 2 == 0) {\n            return num;\n        }\n    }\n    return -1;  // Return a value indicating no even number was found\n}", "unique_id": "MBCPP_221_8", "index": 2037}
{"task_id": "MBCPP/222", "completion": "    for (int i = 1; i < testTuple.size(); ++i) {\n        if (typeid(testTuple[i]) != typeid(testTuple[0])) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_222_4", "index": 2043}
{"task_id": "MBCPP/223", "completion": "    int count = upper_bound(arr.begin(), arr.end(), x) - lower_bound(arr.begin(), arr.end(), x);\n    return count > n / 2;\n}", "unique_id": "MBCPP_223_2", "index": 2051}
{"task_id": "MBCPP/224", "completion": "    int count = 0;\n    while (n > 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}", "unique_id": "MBCPP_224_10", "index": 2069}
{"task_id": "MBCPP/225", "completion": "    if (high < low) \n        return arr[0];\n    if (high == low) \n        return arr[low];\n\n    int mid = low + (high - low) / 2;\n\n    if (mid < high && arr[mid + 1] < arr[mid])\n        return arr[mid + 1];\n    if (mid > low && arr[mid] < arr[mid - 1])\n        return arr[mid];\n\n    if (arr[high] > arr[mid])\n        return findMin(arr, low, mid - 1);\n    return findMin(arr, mid + 1, high);\n}", "unique_id": "MBCPP_225_6", "index": 2075}
{"task_id": "MBCPP/226", "completion": "    string result;\n    for (int i = 0; i < str.length(); i += 2) {\n        result += str[i];\n    }\n    return result;\n}", "unique_id": "MBCPP_226_3", "index": 2082}
{"task_id": "MBCPP/227", "completion": "    return min(a, min(b, c));\n}", "unique_id": "MBCPP_227_8", "index": 2097}
{"task_id": "MBCPP/228", "completion": "    int mask = ((1 << (r - l + 1)) - 1) << (l - 1);\n    return (n & mask) == 0;\n}", "unique_id": "MBCPP_228_1", "index": 2100}
{"task_id": "MBCPP/229", "completion": "    int j = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] < 0) {\n            if (i != j) {\n                swap(arr[i], arr[j]);\n            }\n            ++j;\n        }\n    }\n    return arr;\n}", "unique_id": "MBCPP_229_1", "index": 2110}
{"task_id": "MBCPP/230", "completion": "    size_t pos = 0;\n    while ((pos = str1.find(' ', pos)) != string::npos) {\n        str1.replace(pos, 1, chr);\n        pos += chr.length();\n    }\n    return str1;\n}", "unique_id": "MBCPP_230_10", "index": 2129}
{"task_id": "MBCPP/231", "completion": "    for (int i = n - 2; i >= 0; --i) {\n        for (int j = 0; j <= i; ++j) {\n            tri[i][j] += max(tri[i + 1][j], tri[i + 1][j + 1]);\n        }\n    }\n    return tri[0][0];\n}", "unique_id": "MBCPP_231_4", "index": 2133}
{"task_id": "MBCPP/232", "completion": "    sort(list1.rbegin(), list1.rend());\n    return vector<int>(list1.begin(), list1.begin() + n);\n}", "unique_id": "MBCPP_232_10", "index": 2149}
{"task_id": "MBCPP/233", "completion": "    return 2 * M_PI * r * h;\n}", "unique_id": "MBCPP_233_8", "index": 2157}
{"task_id": "MBCPP/234", "completion": "    return l * l * l;\n}", "unique_id": "MBCPP_234_9", "index": 2168}
{"task_id": "MBCPP/235", "completion": "    for (int i = 0; i < 32; i += 2) {\n        n |= (1 << i);\n    }\n    return n;\n}", "unique_id": "MBCPP_235_3", "index": 2172}
{"task_id": "MBCPP/236", "completion": "    if (k > n) return -1;\n    int totalTriangles = 0;\n    for (int i = 0; i <= n - k; ++i) {\n        totalTriangles += (n - i) * (n - i);\n    }\n    return totalTriangles;\n}", "unique_id": "MBCPP_236_1", "index": 2180}
{"task_id": "MBCPP/238", "completion": "    int n = str.length();\n    return n * (n + 1) / 2;\n}", "unique_id": "MBCPP_238_9", "index": 2198}
{"task_id": "MBCPP/239", "completion": "    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n    for (int j = 1; j <= m; ++j) {\n        dp[1][j] = 1;\n    }\n    for (int len = 2; len <= n; ++len) {\n        for (int j = 1; j <= m; ++j) {\n            for (int k = 1; k <= j / 2; ++k) {\n                dp[len][j] += dp[len - 1][k];\n            }\n        }\n    }\n    int total = 0;\n    for (int j = 1; j <= m; ++j) {\n        total += dp[n][j];\n    }\n    return total;\n}", "unique_id": "MBCPP_239_1", "index": 2200}
{"task_id": "MBCPP/241", "completion": "    return vector<vector<vector<string>>>(o, vector<vector<string>>(n, vector<string>(m, \"*\")));\n}", "unique_id": "MBCPP_241_4", "index": 2213}
{"task_id": "MBCPP/242", "completion": "    return str1.size();\n}", "unique_id": "MBCPP_242_7", "index": 2226}
{"task_id": "MBCPP/244", "completion": "    int root = sqrt(n);\n    if (root * root == n) {\n        root++;\n    } else if (root * root < n) {\n        root++;\n    }\n    return root * root;\n}", "unique_id": "MBCPP_244_8", "index": 2237}
{"task_id": "MBCPP/245", "completion": "    vector<int> inc(n, 0), dec(n, 0);\n    \n    // Initialize increasing and decreasing subsequences with array values\n    for (int i = 0; i < n; i++) {\n        inc[i] = arr[i];\n        dec[i] = arr[i];\n    }\n\n    // Fill the increasing subsequence array\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && inc[i] < inc[j] + arr[i]) {\n                inc[i] = inc[j] + arr[i];\n            }\n        }\n    }\n\n    // Fill the decreasing subsequence array\n    for (int i = n-2; i >= 0; i--) {\n        for (int j = n-1; j > i; j--) {\n            if (arr[i] > arr[j] && dec[i] < dec[j] + arr[i]) {\n                dec[i] = dec[j] + arr[i];\n            }\n        }\n    }\n\n    // Find the maximum value of bi-tonic subsequence\n    int max_sum = 0;\n    for (int i = 0; i < n; i++) {\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i]);\n    }\n\n    return max_sum;\n}", "unique_id": "MBCPP_245_1", "index": 2240}
{"task_id": "MBCPP/246", "completion": "    double x = number;\n    double y = 1;\n    double e = 0.000001; // accuracy level\n\n    while (x - y > e) {\n        x = (x + y) / 2;\n        y = number / x;\n    }\n\n    return x;\n}", "unique_id": "MBCPP_246_6", "index": 2255}
{"task_id": "MBCPP/247", "completion": "    int n = str.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n\n    for (int i = 0; i < n; i++)\n        dp[i][i] = 1;\n\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i < n - cl + 1; i++) {\n            int j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                dp[i][j] = 2;\n            else if (str[i] == str[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            else\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n        }\n    }\n\n    return dp[0][n - 1];\n}", "unique_id": "MBCPP_247_9", "index": 2268}
{"task_id": "MBCPP/248", "completion": "    double sum = 0.0;\n    for (int i = 1; i < n; i++) {\n        sum += 1.0 / i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_248_3", "index": 2272}
{"task_id": "MBCPP/249", "completion": "    vector<int> result;\n    sort(arrayNums1.begin(), arrayNums1.end());\n    sort(arrayNums2.begin(), arrayNums2.end());\n    set_intersection(arrayNums1.begin(), arrayNums1.end(), arrayNums2.begin(), arrayNums2.end(), back_inserter(result));\n    return result;\n}", "unique_id": "MBCPP_249_10", "index": 2289}
{"task_id": "MBCPP/250", "completion": "    return count(tup.begin(), tup.end(), x);\n}", "unique_id": "MBCPP_250_7", "index": 2296}
{"task_id": "MBCPP/251", "completion": "    vector<string> result;\n    for (const auto& item : list) {\n        result.push_back(element);\n        result.push_back(item);\n    }\n    return result;\n}", "unique_id": "MBCPP_251_7", "index": 2306}
{"task_id": "MBCPP/252", "completion": "    double r = abs(complex<double>(numbers, 0));\n    double theta = arg(complex<double>(numbers, 0));\n    return {r, theta};\n}", "unique_id": "MBCPP_252_5", "index": 2314}
{"task_id": "MBCPP/253", "completion": "    return list1.size();\n}", "unique_id": "MBCPP_253_10", "index": 2329}
{"task_id": "MBCPP/254", "completion": "    vector<string> result;\n    stringstream ss(text);\n    string word;\n    while (ss >> word) {\n        if (word[0] == 'a' || word[0] == 'e') {\n            result.push_back(word);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_254_7", "index": 2336}
{"task_id": "MBCPP/255", "completion": "    vector<vector<string>> result;\n    vector<string> combination(n);\n\n    function<void(int, int)> generate = [&](int start, int depth) {\n        if (depth == n) {\n            result.push_back(combination);\n            return;\n        }\n        for (int i = start; i < l.size(); ++i) {\n            combination[depth] = l[i];\n            generate(i, depth + 1);\n        }\n    };\n\n    generate(0, 0);\n    return result;\n}", "unique_id": "MBCPP_255_3", "index": 2342}
{"task_id": "MBCPP/256", "completion": "    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}", "unique_id": "MBCPP_256_3", "index": 2352}
{"task_id": "MBCPP/257", "completion": "    return {b, a};\n}", "unique_id": "MBCPP_257_5", "index": 2364}
{"task_id": "MBCPP/258", "completion": "    return count_if(arrayNums.begin(), arrayNums.end(), [](int num) { return num % 2 != 0; });\n}", "unique_id": "MBCPP_258_8", "index": 2377}
{"task_id": "MBCPP/259", "completion": "    vector<vector<int>> result;\n    for (int i = 0; i < testTup1.size(); i++) {\n        vector<int> maxTup;\n        maxTup.push_back(max(testTup1[i][0], testTup2[i][0]));\n        maxTup.push_back(max(testTup1[i][1], testTup2[i][1]));\n        result.push_back(maxTup);\n    }\n    return result;\n}", "unique_id": "MBCPP_259_8", "index": 2387}
{"task_id": "MBCPP/260", "completion": "    if (n == 0 || n == 1)\n        return 1;\n    vector<int> ns(n + 1);\n    ns[0] = 1;\n    ns[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        ns[i] = 2 * ns[i - 1] + ns[i - 2];\n    }\n    return ns[n];\n}", "unique_id": "MBCPP_260_8", "index": 2397}
{"task_id": "MBCPP/261", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] / testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_261_1", "index": 2400}
{"task_id": "MBCPP/263", "completion": "    for (const auto& pair : d2) {\n        d1[pair.first] = pair.second;\n    }\n    return d1;\n}", "unique_id": "MBCPP_263_2", "index": 2411}
{"task_id": "MBCPP/264", "completion": "    if (hAge <= 0) return 0;\n    if (hAge == 1) return 15;\n    if (hAge == 2) return 15 + 9;\n    return 24 + (hAge - 2) * 5;\n}", "unique_id": "MBCPP_264_5", "index": 2424}
{"task_id": "MBCPP/266", "completion": "    return 4 * l * l;\n}", "unique_id": "MBCPP_266_1", "index": 2430}
{"task_id": "MBCPP/267", "completion": "    int sum = 0;\n    for (int i = 1, count = 0; count < n; i += 2, ++count) {\n        sum += i * i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_267_9", "index": 2448}
{"task_id": "MBCPP/268", "completion": "    return 6 * n * (n - 1) + 1;\n}", "unique_id": "MBCPP_268_4", "index": 2453}
{"task_id": "MBCPP/269", "completion": "    return k[0];\n}", "unique_id": "MBCPP_269_7", "index": 2466}
{"task_id": "MBCPP/270", "completion": "    int sum = 0;\n    for (int i = 0; i < n; i += 2) {\n        if (arr[i] % 2 == 0) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_270_10", "index": 2479}
{"task_id": "MBCPP/271", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        int evenNumber = 2 * i;\n        sum += pow(evenNumber, 5);\n    }\n    return sum;\n}", "unique_id": "MBCPP_271_8", "index": 2487}
{"task_id": "MBCPP/273", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] - testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_273_3", "index": 2492}
{"task_id": "MBCPP/274", "completion": "    int sum = 0;\n    for (int i = 0; i <= n; i += 2) {\n        sum += (1 << (n - i));\n    }\n    return sum;\n}", "unique_id": "MBCPP_274_5", "index": 2504}
{"task_id": "MBCPP/275", "completion": "    queue<int> q;\n    for (int i = 0; i < n; i++) {\n        q.push(i + 1);\n    }\n    int count = 0;\n    while (!q.empty()) {\n        count++;\n        int front = q.front();\n        q.pop();\n        if (count % m != 0) {\n            q.push(front);\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_275_7", "index": 2516}
{"task_id": "MBCPP/276", "completion": "    return M_PI * r * r * h;\n}", "unique_id": "MBCPP_276_3", "index": 2522}
{"task_id": "MBCPP/277", "completion": "    unordered_map<string, int> result;\n    for (const auto& pair : dict) {\n        if (pair.second >= n) {\n            result[pair.first] = pair.second;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_277_8", "index": 2537}
{"task_id": "MBCPP/279", "completion": "    return n * (4 * n - 3);\n}", "unique_id": "MBCPP_279_1", "index": 2540}
{"task_id": "MBCPP/281", "completion": "    unordered_set<int> elements;\n    for (int num : testList) {\n        if (elements.find(num) != elements.end()) {\n            return false;\n        }\n        elements.insert(num);\n    }\n    return true;\n}", "unique_id": "MBCPP_281_3", "index": 2552}
{"task_id": "MBCPP/282", "completion": "    transform(nums1.begin(), nums1.end(), nums2.begin(), nums1.begin(), [](int a, int b) { return a - b; });\n    return nums1;\n}", "unique_id": "MBCPP_282_3", "index": 2562}
{"task_id": "MBCPP/283", "completion": "    vector<int> digit_count(10, 0);\n    int temp = n;\n    while (temp > 0) {\n        digit_count[temp % 10]++;\n        temp /= 10;\n    }\n    temp = n;\n    while (temp > 0) {\n        int digit = temp % 10;\n        if (digit_count[digit] > digit) {\n            return false;\n        }\n        temp /= 10;\n    }\n    return true;\n}", "unique_id": "MBCPP_283_2", "index": 2571}
{"task_id": "MBCPP/285", "completion": "    regex pattern(\"ab{2,3}\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_285_2", "index": 2581}
{"task_id": "MBCPP/286", "completion": "    int max_sum = INT_MIN, current_sum = 0;\n    int total_sum = accumulate(a.begin(), a.end(), 0);\n    \n    for (int i = 0; i < n * min(k, 2); ++i) {\n        current_sum += a[i % n];\n        max_sum = max(max_sum, current_sum);\n        if (current_sum < 0) current_sum = 0;\n    }\n\n    if (k > 2 && total_sum > 0) {\n        max_sum += total_sum * (k - 2);\n    }\n\n    return max_sum;\n}", "unique_id": "MBCPP_286_9", "index": 2598}
{"task_id": "MBCPP/287", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += (2 * i) * (2 * i);\n    }\n    return sum;\n}", "unique_id": "MBCPP_287_9", "index": 2608}
{"task_id": "MBCPP/288", "completion": "    int count = 0;\n    for (int i = 0; i < n; i++) {\n        bool found = false;\n        for (int j = 1; j < p; j++) {\n            if ((arr[i] * j) % p == 1) {\n                if (j == arr[i]) {\n                    found = true;\n                }\n                break;\n            }\n        }\n        if (found) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_288_5", "index": 2614}
{"task_id": "MBCPP/289", "completion": "    return (n + n / 4 - n / 100 + n / 400) % 7;\n}", "unique_id": "MBCPP_289_4", "index": 2623}
{"task_id": "MBCPP/291", "completion": "    if (n == 0) return 0;\n    if (n == 1) return k;\n\n    int same = k; \n    int diff = k * (k - 1);\n    int total = same + diff;\n\n    for (int i = 3; i <= n; i++) {\n        same = diff;\n        diff = total * (k - 1);\n        total = same + diff;\n    }\n\n    return total;\n}", "unique_id": "MBCPP_291_4", "index": 2633}
{"task_id": "MBCPP/292", "completion": "    return n / m;\n}", "unique_id": "MBCPP_292_2", "index": 2641}
{"task_id": "MBCPP/295", "completion": "    int sum = 0;\n    for (int i = 1; i <= number / 2; i++) {\n        if (number % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_295_4", "index": 2653}
{"task_id": "MBCPP/296", "completion": "    int inv_count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}", "unique_id": "MBCPP_296_1", "index": 2660}
{"task_id": "MBCPP/297", "completion": "    vector<int> result;\n    for (const auto& sublist : list1) {\n        result.insert(result.end(), sublist.begin(), sublist.end());\n    }\n    return result;\n}", "unique_id": "MBCPP_297_2", "index": 2671}
{"task_id": "MBCPP/300", "completion": "    double result = 1.0;\n    for (int i = 0; i < n; ++i) {\n        result *= (n + i + 1) / double(i + 1);\n    }\n    result /= (n + 1);\n    return result;\n}", "unique_id": "MBCPP_300_1", "index": 2680}
{"task_id": "MBCPP/302", "completion": "    if (n == 0) return 0;\n    int msb = 0;\n    while (n > 1) {\n        n = n >> 1;\n        msb++;\n    }\n    return 1 << msb;\n}", "unique_id": "MBCPP_302_5", "index": 2694}
{"task_id": "MBCPP/303", "completion": "    int type1 = 0, type2 = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (a[i] > a[j])\n                type1++;\n            if (a[i] < a[j])\n                type2++;\n        }\n    }\n    return type1 == type2;\n}", "unique_id": "MBCPP_303_5", "index": 2704}
{"task_id": "MBCPP/304", "completion": "    for (int i = rotations - 1; i >= 0; i--) {\n        int l = ranges[i][0];\n        int r = ranges[i][1];\n        if (index >= l && index <= r) {\n            if (index == l) {\n                index = r;\n            } else {\n                index--;\n            }\n        }\n    }\n    return arr[index];\n}", "unique_id": "MBCPP_304_2", "index": 2711}
{"task_id": "MBCPP/305", "completion": "    vector<string> result;\n    for (const string& word : words) {\n        istringstream iss(word);\n        string token;\n        while (iss >> token) {\n            if (token[0] == 'p' || token[0] == 'P') {\n                result.push_back(token);\n                if (result.size() == 2) {\n                    return result;\n                }\n            }\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_305_1", "index": 2720}
{"task_id": "MBCPP/306", "completion": "    vector<int> dp(n, 0);\n    dp[0] = a[0];\n\n    for (int i = 1; i < n; ++i) {\n        dp[i] = a[i];\n        for (int j = 0; j < i; ++j) {\n            if (a[i] > a[j] && dp[i] < dp[j] + a[i]) {\n                dp[i] = dp[j] + a[i];\n            }\n        }\n    }\n\n    int max_sum = 0;\n    for (int i = 0; i <= index; ++i) {\n        if (a[i] < a[k] && max_sum < dp[i]) {\n            max_sum = dp[i];\n        }\n    }\n\n    return max_sum + a[k];\n}", "unique_id": "MBCPP_306_3", "index": 2732}
{"task_id": "MBCPP/308", "completion": "    priority_queue<int, vector<int>, greater<int>> pq;\n    for(int i = 0; i < nums1.size(); i++) {\n        for(int j = 0; j < nums2.size(); j++) {\n            int product = nums1[i] * nums2[j];\n            if(pq.size() < n) {\n                pq.push(product);\n            } else if(product > pq.top()) {\n                pq.pop();\n                pq.push(product);\n            }\n        }\n    }\n    vector<int> result;\n    while(!pq.empty()) {\n        result.push_back(pq.top());\n        pq.pop();\n    }\n    sort(result.rbegin(), result.rend());\n    return result;\n}", "unique_id": "MBCPP_308_6", "index": 2745}
{"task_id": "MBCPP/309", "completion": "    return (a > b) ? a : b;\n}", "unique_id": "MBCPP_309_6", "index": 2755}
{"task_id": "MBCPP/310", "completion": "    vector<string> result;\n    for (char c : str1) {\n        result.push_back(string(1, c));\n    }\n    return result;\n}", "unique_id": "MBCPP_310_3", "index": 2762}
{"task_id": "MBCPP/311", "completion": "    if ((n & (n + 1)) == 0)\n        return n;\n    int pos = 1;\n    while (n & pos)\n        pos <<= 1;\n    return n | pos;\n}", "unique_id": "MBCPP_311_3", "index": 2772}
{"task_id": "MBCPP/312", "completion": "    return (M_PI * r * r * h) / 3.0;\n}", "unique_id": "MBCPP_312_4", "index": 2783}
{"task_id": "MBCPP/314", "completion": "    vector<int> dp(n, 0);\n    dp[0] = max(grid[0][0], grid[1][0]);\n    if (n == 1) return dp[0];\n    dp[1] = max(dp[0], max(grid[0][1], grid[1][1]));\n\n    for (int i = 2; i < n; ++i) {\n        dp[i] = max(dp[i-1], dp[i-2] + max(grid[0][i], grid[1][i]));\n    }\n\n    return dp[n-1];\n}", "unique_id": "MBCPP_314_7", "index": 2796}
{"task_id": "MBCPP/315", "completion": "    istringstream iss(str);\n    string word, result = \"-1\";\n    int maxLength = 0;\n    while (iss >> word) {\n        if (word.length() % 2 == 0 && word.length() > maxLength) {\n            maxLength = word.length();\n            result = word;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_315_5", "index": 2804}
{"task_id": "MBCPP/316", "completion": "    int low = 0, high = a.size() - 1, result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (a[mid] == x) {\n            result = mid;\n            low = mid + 1;\n        } else if (a[mid] < x) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_316_3", "index": 2812}
{"task_id": "MBCPP/318", "completion": "    int maxVol = 0;\n    for (int x = 1; x <= s / 3; ++x) {\n        for (int y = x; y <= (s - x) / 2; ++y) {\n            int z = s - x - y;\n            maxVol = max(maxVol, x * y * z);\n        }\n    }\n    return maxVol;\n}", "unique_id": "MBCPP_318_8", "index": 2827}
{"task_id": "MBCPP/319", "completion": "    vector<string> result;\n    regex word_regex(\"\\\\b\\\\w{5}\\\\b\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), word_regex);\n    auto words_end = sregex_iterator();\n\n    for (auto it = words_begin; it != words_end; ++it) {\n        result.push_back(it->str());\n    }\n\n    return result;\n}", "unique_id": "MBCPP_319_10", "index": 2839}
{"task_id": "MBCPP/320", "completion": "    int sum_of_numbers = n * (n + 1) / 2;\n    int sum_of_squares = n * (n + 1) * (2 * n + 1) / 6;\n    int square_of_sum = sum_of_numbers * sum_of_numbers;\n    return square_of_sum - sum_of_squares;\n}", "unique_id": "MBCPP_320_7", "index": 2846}
{"task_id": "MBCPP/321", "completion": "    int n = s.length();\n    string result;\n    for (int i = 1; i <= n; ++i) {\n        result += to_string(i);\n    }\n    for (int i = n - 1; i >= 1; --i) {\n        result += to_string(i);\n    }\n    return result;\n}", "unique_id": "MBCPP_321_8", "index": 2857}
{"task_id": "MBCPP/322", "completion": "    vector<int> positions;\n    if (list1.empty()) return positions;\n\n    int min_value = *min_element(list1.begin(), list1.end());\n    for (int i = 0; i < list1.size(); ++i) {\n        if (list1[i] == min_value) {\n            positions.push_back(i);\n        }\n    }\n    return positions;\n}", "unique_id": "MBCPP_322_8", "index": 2867}
{"task_id": "MBCPP/323", "completion": "    vector<int> pos;\n    vector<int> neg;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] >= 0) {\n            pos.push_back(arr[i]);\n        } else {\n            neg.push_back(arr[i]);\n        }\n    }\n\n    int i = 0, j = 0, k = 0;\n    while (i < neg.size() && j < pos.size()) {\n        if (k % 2 == 0) {\n            arr[k++] = neg[i++];\n        } else {\n            arr[k++] = pos[j++];\n        }\n    }\n\n    while (i < neg.size()) {\n        arr[k++] = neg[i++];\n    }\n\n    while (j < pos.size()) {\n        arr[k++] = pos[j++];\n    }\n\n    return arr;\n}", "unique_id": "MBCPP_323_10", "index": 2879}
{"task_id": "MBCPP/324", "completion": "    int sum1 = 0, sum2 = 0;\n    for (int i = 0; i < testTuple.size(); i++) {\n        if (i % 2 == 0) {\n            sum1 += testTuple[i];\n        } else {\n            sum2 += testTuple[i];\n        }\n    }\n    return {sum1, sum2};\n}", "unique_id": "MBCPP_324_2", "index": 2881}
{"task_id": "MBCPP/325", "completion": "    if (n <= 3) return n;\n\n    vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j * j <= i; ++j) {\n            dp[i] = min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n\n    return dp[n];\n}", "unique_id": "MBCPP_325_7", "index": 2896}
{"task_id": "MBCPP/326", "completion": "    map<string, int> wordCount;\n    for (const auto& sentence : testList) {\n        istringstream stream(sentence);\n        string word;\n        while (stream >> word) {\n            wordCount[word]++;\n        }\n    }\n    \n    string mostOccurringWord;\n    int maxCount = 0;\n    for (const auto& entry : wordCount) {\n        if (entry.second > maxCount) {\n            maxCount = entry.second;\n            mostOccurringWord = entry.first;\n        }\n    }\n    \n    return mostOccurringWord;\n}", "unique_id": "MBCPP_326_5", "index": 2904}
{"task_id": "MBCPP/327", "completion": "    return (x == y || y == z || x == z);\n}", "unique_id": "MBCPP_327_9", "index": 2918}
{"task_id": "MBCPP/328", "completion": "    int len = list1.size();\n    if (len == 0) return list1;\n    m = m % len; // Handle cases where m is greater than the length of the list\n    vector<int> rotated_list;\n\n    // Append the sublists in the rotated order\n    rotated_list.insert(rotated_list.end(), list1.begin() + m, list1.end());\n    rotated_list.insert(rotated_list.end(), list1.begin(), list1.begin() + m);\n\n    // Resize the list to the first n elements\n    rotated_list.resize(n);\n\n    return rotated_list;\n}", "unique_id": "MBCPP_328_7", "index": 2926}
{"task_id": "MBCPP/329", "completion": "    int count = 0;\n    for (int num : list) {\n        if (num < 0) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_329_9", "index": 2938}
{"task_id": "MBCPP/330", "completion": "    vector<string> result;\n    regex pattern(\"\\\\b\\\\w{3,5}\\\\b\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), pattern);\n    auto words_end = sregex_iterator();\n    \n    for (auto it = words_begin; it != words_end; ++it) {\n        result.push_back(it->str());\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_330_3", "index": 2942}
{"task_id": "MBCPP/331", "completion": "    int count = 0;\n    while (n > 0) {\n        if ((n & 1) == 0) {\n            count++;\n        }\n        n >>= 1;\n    }\n    return count;\n}", "unique_id": "MBCPP_331_1", "index": 2950}
{"task_id": "MBCPP/332", "completion": "    unordered_map<string, int> freq;\n    for (char c : str1) {\n        string ch(1, c);\n        freq[ch]++;\n    }\n    return freq;\n}", "unique_id": "MBCPP_332_7", "index": 2966}
{"task_id": "MBCPP/334", "completion": "    if (a + b > c && a + c > b && b + c > a)\n        return true;\n    else\n        return false;\n}", "unique_id": "MBCPP_334_1", "index": 2970}
{"task_id": "MBCPP/335", "completion": "    return n / 2.0 * (2 * a + (n - 1) * d);\n}", "unique_id": "MBCPP_335_1", "index": 2980}
{"task_id": "MBCPP/336", "completion": "    return monthname1 == \"February\";\n}", "unique_id": "MBCPP_336_6", "index": 2995}
{"task_id": "MBCPP/337", "completion": "    regex pattern(R\"(\\bpython\\b[[:punct:]]*$)\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_337_6", "index": 3005}
{"task_id": "MBCPP/338", "completion": "    int count = 0;\n    unordered_map<char, int> freq;\n    \n    for (char c : s) {\n        count += freq[c];\n        freq[c]++;\n    }\n    \n    return count + s.length();\n}", "unique_id": "MBCPP_338_5", "index": 3014}
{"task_id": "MBCPP/339", "completion": "    vector<int> count(1001, 0);\n    for (int i = x; i <= y; ++i) {\n        for (int j = 1; j <= sqrt(i); ++j) {\n            if (i % j == 0) {\n                count[j]++;\n                if (j != i / j) {\n                    count[i / j]++;\n                }\n            }\n        }\n    }\n    int maxCount = 0;\n    int divisor = 1;\n    for (int i = 1; i <= 1000; ++i) {\n        if (count[i] > maxCount) {\n            maxCount = count[i];\n            divisor = i;\n        }\n    }\n    return divisor;\n}", "unique_id": "MBCPP_339_4", "index": 3023}
{"task_id": "MBCPP/340", "completion": "    sort(lst.begin(), lst.end());\n    int count = 0;\n    int sum = 0;\n    for (int num : lst) {\n        if (num > 0) {\n            sum += num;\n            count++;\n            if (count == 3) break;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_340_7", "index": 3036}
{"task_id": "MBCPP/341", "completion": "    vector<int> result(s.begin(), s.end());\n    return result;\n}", "unique_id": "MBCPP_341_3", "index": 3042}
{"task_id": "MBCPP/342", "completion": "    int n = list.size();\n    vector<int> ptr(n, 0);\n    auto compare = [&](const pair<int, int>& a, const pair<int, int>& b) {\n        return list[a.first][a.second] > list[b.first][b.second];\n    };\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compare)> minHeap(compare);\n    int maxVal = INT_MIN;\n    \n    for (int i = 0; i < n; ++i) {\n        minHeap.push({i, 0});\n        maxVal = max(maxVal, list[i][0]);\n    }\n    \n    int start = 0, end = INT_MAX;\n    while (true) {\n        auto [row, col] = minHeap.top();\n        minHeap.pop();\n        int minVal = list[row][col];\n        \n        if (maxVal - minVal < end - start) {\n            start = minVal;\n            end = maxVal;\n        }\n        \n        if (col + 1 < list[row].size()) {\n            minHeap.push({row, col + 1});\n            maxVal = max(maxVal, list[row][col + 1]);\n        } else {\n            break;\n        }\n    }\n    \n    return {start, end};\n}", "unique_id": "MBCPP_342_8", "index": 3057}
{"task_id": "MBCPP/343", "completion": "    int letters = 0, digits = 0;\n    for (char c : s) {\n        if (isalpha(c)) {\n            letters++;\n        } else if (isdigit(c)) {\n            digits++;\n        }\n    }\n    return {letters, digits};\n}", "unique_id": "MBCPP_343_7", "index": 3066}
{"task_id": "MBCPP/344", "completion": "    int count = 0;\n    for (int i = ceil(sqrt(n)); i * i <= m; ++i) {\n        if (i % 2 == 1) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_344_5", "index": 3074}
{"task_id": "MBCPP/345", "completion": "    vector<int> result;\n    for (size_t i = 1; i < nums.size(); ++i) {\n        result.push_back(nums[i] - nums[i - 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_345_5", "index": 3084}
{"task_id": "MBCPP/346", "completion": "    if (n == 0 && k == 0)\n        return 1;\n    if (n == k)\n        return zigzag(n - 1, k - 1);\n    if (k == 0)\n        return zigzag(n - 1, n - 1);\n    return zigzag(n - 1, k - 1) + zigzag(n - 1, k);\n}", "unique_id": "MBCPP_346_2", "index": 3091}
{"task_id": "MBCPP/347", "completion": "    int count = 0;\n    for (int i = 1; i <= min(m, n); ++i) {\n        count += (m - i + 1) * (n - i + 1);\n    }\n    return count;\n}", "unique_id": "MBCPP_347_7", "index": 3106}
{"task_id": "MBCPP/348", "completion": "    vector<vector<int>> dp(m + 1, vector<int>(m + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            if (j > 0) dp[i][j] += dp[i - 1][j - 1];\n            if (j < m) dp[i][j] += dp[i - 1][j + 1];\n        }\n    }\n    \n    return dp[m][0];\n}", "unique_id": "MBCPP_348_3", "index": 3112}
{"task_id": "MBCPP/349", "completion": "    for (char c : str) {\n        if (c != '0' && c != '1') {\n            return \"No\";\n        }\n    }\n    return \"Yes\";\n}", "unique_id": "MBCPP_349_4", "index": 3123}
{"task_id": "MBCPP/350", "completion": "    unordered_map<char, int> freq;\n    for (char c : s) {\n        freq[c]++;\n    }\n    int max_freq = 0;\n    for (auto& entry : freq) {\n        max_freq = max(max_freq, entry.second);\n    }\n    return s.length() - max_freq;\n}", "unique_id": "MBCPP_350_3", "index": 3132}
{"task_id": "MBCPP/351", "completion": "    unordered_map<int, int> countMap;\n    for (int num : arr) {\n        countMap[num]++;\n        if (countMap[num] == k) {\n            return num;\n        }\n    }\n    return -1;\n}", "unique_id": "MBCPP_351_10", "index": 3149}
{"task_id": "MBCPP/352", "completion": "    unordered_set<char> charSet;\n    for (char c : str) {\n        if (charSet.find(c) != charSet.end()) {\n            return false;\n        }\n        charSet.insert(c);\n    }\n    return true;\n}", "unique_id": "MBCPP_352_9", "index": 3158}
{"task_id": "MBCPP/353", "completion": "    for (auto& row : list1) {\n        if (n >= 0 && n < row.size()) {\n            row.erase(row.begin() + n);\n        }\n    }\n    return list1;\n}", "unique_id": "MBCPP_353_6", "index": 3165}
{"task_id": "MBCPP/354", "completion": "    return a + (n - 1) * d;\n}", "unique_id": "MBCPP_354_7", "index": 3176}
{"task_id": "MBCPP/355", "completion": "    int count = 0;\n    for (int x1 = -radius; x1 <= radius; ++x1) {\n        for (int y1 = -radius; y1 <= radius; ++y1) {\n            for (int x2 = x1; x2 <= radius; ++x2) {\n                for (int y2 = y1; y2 <= radius; ++y2) {\n                    if (x1 != x2 && y1 != y2) {\n                        if (x1 * x1 + y1 * y1 <= radius * radius && x2 * x2 + y2 * y2 <= radius * radius) {\n                            ++count;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count / 2;\n}", "unique_id": "MBCPP_355_2", "index": 3181}
{"task_id": "MBCPP/356", "completion": "    return 180 - (a + b);\n}", "unique_id": "MBCPP_356_2", "index": 3191}
{"task_id": "MBCPP/357", "completion": "    int maxElement = INT_MAX;\n    for (const auto& tuple : testList) {\n        for (int num : tuple) {\n            if (num > maxElement) {\n                maxElement = num;\n            }\n        }\n    }\n    return maxElement;\n}", "unique_id": "MBCPP_357_1", "index": 3200}
{"task_id": "MBCPP/358", "completion": "    vector<int> result(nums1.size());\n    transform(nums1.begin(), nums1.end(), nums2.begin(), result.begin(), [](int a, int b) {\n        return a % b;\n    });\n    return result;\n}", "unique_id": "MBCPP_358_3", "index": 3212}
{"task_id": "MBCPP/359", "completion": "    int discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) return \"No\";\n    \n    double root1 = (-b + sqrt(discriminant)) / (2.0 * a);\n    double root2 = (-b - sqrt(discriminant)) / (2.0 * a);\n    \n    if (root1 == 2 * root2 || root2 == 2 * root1) return \"Yes\";\n    return \"No\";\n}", "unique_id": "MBCPP_359_8", "index": 3227}
{"task_id": "MBCPP/360", "completion": "    return (1 << (2 * n)) - (1 << (n + 1)) - 1;\n}", "unique_id": "MBCPP_360_1", "index": 3230}
{"task_id": "MBCPP/363", "completion": "    for(auto &row : testList) {\n        for(auto &element : row) {\n            element += k;\n        }\n    }\n    return testList;\n}", "unique_id": "MBCPP_363_6", "index": 3245}
{"task_id": "MBCPP/364", "completion": "    int cnt1 = 0, cnt2 = 0;\n    for (int i = 0; i < str.length(); i++) {\n        if (i % 2 == 0) {\n            if (str[i] != '0') cnt1++;\n            if (str[i] != '1') cnt2++;\n        } else {\n            if (str[i] != '1') cnt1++;\n            if (str[i] != '0') cnt2++;\n        }\n    }\n    return min(cnt1, cnt2);\n}", "unique_id": "MBCPP_364_3", "index": 3252}
{"task_id": "MBCPP/365", "completion": "    return n == 0 ? 0 : floor(log10(abs(n))) + 1;\n}", "unique_id": "MBCPP_365_3", "index": 3262}
{"task_id": "MBCPP/366", "completion": "    int maxProduct = INT_MIN;\n    for (size_t i = 0; i < listNums.size() - 1; ++i) {\n        int product = listNums[i] * listNums[i + 1];\n        if (product > maxProduct) {\n            maxProduct = product;\n        }\n    }\n    return maxProduct;\n}", "unique_id": "MBCPP_366_8", "index": 3277}
{"task_id": "MBCPP/368", "completion": "    vector<vector<int>> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(testTup);\n    }\n    return result;\n}", "unique_id": "MBCPP_368_6", "index": 3285}
{"task_id": "MBCPP/369", "completion": "    return 2 * h * (l + w);\n}", "unique_id": "MBCPP_369_6", "index": 3295}
{"task_id": "MBCPP/370", "completion": "    sort(price.begin(), price.end(), [](const vector<string>& a, const vector<string>& b) {\n        return stof(a[1]) > stof(b[1]);\n    });\n    return price;\n}", "unique_id": "MBCPP_370_7", "index": 3306}
{"task_id": "MBCPP/371", "completion": "    if (leftElement > rightElement)\n        return leftElement;\n    int mid = leftElement + (rightElement - leftElement) / 2;\n    if (a[mid] == mid)\n        return smallestMissing(a, mid + 1, rightElement);\n    else\n        return smallestMissing(a, leftElement, mid - 1);\n}", "unique_id": "MBCPP_371_2", "index": 3311}
{"task_id": "MBCPP/372", "completion": "    priority_queue<int, vector<int>, greater<int>> minHeap(nums.begin(), nums.end());\n    vector<int> sorted;\n    while (!minHeap.empty()) {\n        sorted.push_back(minHeap.top());\n        minHeap.pop();\n    }\n    return sorted;\n}", "unique_id": "MBCPP_372_2", "index": 3321}
{"task_id": "MBCPP/373", "completion": "    return l * w * h;\n}", "unique_id": "MBCPP_373_8", "index": 3337}
{"task_id": "MBCPP/374", "completion": "    vector<string> result;\n    sort(str.begin(), str.end());\n    do {\n        result.push_back(str);\n    } while (next_permutation(str.begin(), str.end()));\n    return result;\n}", "unique_id": "MBCPP_374_8", "index": 3347}
{"task_id": "MBCPP/375", "completion": "    return round((double)n / m) * m;\n}", "unique_id": "MBCPP_375_3", "index": 3352}
{"task_id": "MBCPP/377", "completion": "    s.erase(remove(s.begin(), s.end(), c[0]), s.end());\n    return s;\n}", "unique_id": "MBCPP_377_1", "index": 3360}
{"task_id": "MBCPP/378", "completion": "    if (testList.empty()) {\n        return testList;\n    }\n    int lastElement = testList.back();\n    testList.pop_back();\n    testList.insert(testList.begin(), lastElement);\n    return testList;\n}", "unique_id": "MBCPP_378_1", "index": 3370}
{"task_id": "MBCPP/379", "completion": "    return 2 * (l * w + w * h + h * l);\n}", "unique_id": "MBCPP_379_10", "index": 3389}
{"task_id": "MBCPP/380", "completion": "    vector<vector<int>> result(rownum, vector<int>(colnum));\n    for (int i = 0; i < rownum; ++i) {\n        for (int j = 0; j < colnum; ++j) {\n            result[i][j] = i * j;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_380_2", "index": 3391}
{"task_id": "MBCPP/382", "completion": "    int low = 0, high = a.size() - 1;\n    while (low <= high) {\n        if (a[low] <= a[high]) return low;\n        int mid = low + (high - low) / 2;\n        int next = (mid + 1) % a.size();\n        int prev = (mid - 1 + a.size()) % a.size();\n        if (a[mid] <= a[next] && a[mid] <= a[prev]) return mid;\n        else if (a[mid] <= a[high]) high = mid - 1;\n        else if (a[mid] >= a[low]) low = mid + 1;\n    }\n    return -1;\n}", "unique_id": "MBCPP_382_8", "index": 3407}
{"task_id": "MBCPP/383", "completion": "    int mask = 0xAAAAAAAA; // Mask with all even bits set to 1 (32-bit)\n    return n ^ mask;\n}", "unique_id": "MBCPP_383_2", "index": 3411}
{"task_id": "MBCPP/384", "completion": "    if (n == 0) return 0;\n    int smallest = *min_element(arr.begin(), arr.end());\n    return count(arr.begin(), arr.end(), smallest);\n}", "unique_id": "MBCPP_384_2", "index": 3421}
{"task_id": "MBCPP/385", "completion": "    if (n == 0)\n        return 3;\n    if (n == 1)\n        return 0;\n    if (n == 2)\n        return 2;\n    return getPerrin(n - 2) + getPerrin(n - 3);\n}", "unique_id": "MBCPP_385_4", "index": 3433}
{"task_id": "MBCPP/386", "completion": "    int countLeft = 0, countRight = 0, swap = 0, imbalance = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '[') {\n            countLeft++;\n            if (imbalance > 0) {\n                swap += imbalance;\n                imbalance--;\n            }\n        } else if (s[i] == ']') {\n            countRight++;\n            imbalance = countRight - countLeft;\n        }\n    }\n    return swap;\n}", "unique_id": "MBCPP_386_7", "index": 3446}
{"task_id": "MBCPP/387", "completion": "    char last_digit = n.back();\n    if (last_digit >= '0' && last_digit <= '9') {\n        return (last_digit - '0') % 2 == 0 ? \"Even\" : \"Odd\";\n    } else {\n        return (last_digit - 'A' + 10) % 2 == 0 ? \"Even\" : \"Odd\";\n    }\n}", "unique_id": "MBCPP_387_3", "index": 3452}
{"task_id": "MBCPP/388", "completion": "    int res = 1;\n    while (res <= n) {\n        res <<= 1;\n    }\n    return res >> 1;\n}", "unique_id": "MBCPP_388_9", "index": 3468}
{"task_id": "MBCPP/389", "completion": "    if (n == 0)\n        return 2;\n    if (n == 1)\n        return 1;\n    return findLucas(n - 1) + findLucas(n - 2);\n}", "unique_id": "MBCPP_389_9", "index": 3478}
{"task_id": "MBCPP/391", "completion": "    vector<unordered_map<string, unordered_map<string, int>>> result;\n    for (size_t i = 0; i < l1.size(); ++i) {\n        result.push_back({{l1[i], {{l2[i], l3[i]}}}});\n    }\n    return result;\n}", "unique_id": "MBCPP_391_2", "index": 3481}
{"task_id": "MBCPP/392", "completion": "    static unordered_map<int, int> memo;\n    if (n == 0)\n        return 0;\n    if (memo.find(n) != memo.end())\n        return memo[n];\n    int result = max(n, getMaxSum(n/2) + getMaxSum(n/3) + getMaxSum(n/4) + getMaxSum(n/5));\n    memo[n] = result;\n    return result;\n}", "unique_id": "MBCPP_392_3", "index": 3492}
{"task_id": "MBCPP/394", "completion": "    unordered_set<int> elements;\n    for (int num : testTup) {\n        if (elements.find(num) != elements.end()) {\n            return false;\n        }\n        elements.insert(num);\n    }\n    return true;\n}", "unique_id": "MBCPP_394_6", "index": 3505}
{"task_id": "MBCPP/396", "completion": "    if (regex_match(str, regex(\"^(.).*\\1$\"))) {\n        return \"Valid\";\n    } else {\n        return \"Invalid\";\n    }\n}", "unique_id": "MBCPP_396_10", "index": 3519}
{"task_id": "MBCPP/397", "completion": "    if ((a > b && a < c) || (a > c && a < b))\n        return a;\n    else if ((b > a && b < c) || (b > c && b < a))\n        return b;\n    else\n        return c;\n}", "unique_id": "MBCPP_397_9", "index": 3528}
{"task_id": "MBCPP/398", "completion": "    int sum = 0;\n    for (int num : nums) {\n        num = abs(num);  // handle negative numbers\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_398_4", "index": 3533}
{"task_id": "MBCPP/399", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] ^ testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_399_9", "index": 3548}
{"task_id": "MBCPP/400", "completion": "    map<pair<int, int>, int> freq;\n    for (auto &pair : testList) {\n        sort(pair.begin(), pair.end());\n        freq[{pair[0], pair[1]}]++;\n    }\n    return freq.size();\n}", "unique_id": "MBCPP_400_4", "index": 3553}
{"task_id": "MBCPP/401", "completion": "    vector<vector<int>> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        vector<int> temp;\n        for (size_t j = 0; j < testTup1[i].size(); ++j) {\n            temp.push_back(testTup1[i][j] + testTup2[i][j]);\n        }\n        result.push_back(temp);\n    }\n    return result;\n}", "unique_id": "MBCPP_401_4", "index": 3563}
{"task_id": "MBCPP/402", "completion": "    if (r > n) return 0;\n    if (r == 0 || r == n) return 1;\n    \n    vector<int> C(r + 1, 0);\n    C[0] = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = min(i, r); j > 0; j--) {\n            C[j] = (C[j] + C[j-1]) % p;\n        }\n    }\n    \n    return C[r];\n}", "unique_id": "MBCPP_402_9", "index": 3578}
{"task_id": "MBCPP/403", "completion": "    const regex pattern(\"(https?|ftp)://[^\\\\s/$.?#].[^\\\\s]*\");\n    return regex_match(str, pattern);\n}", "unique_id": "MBCPP_403_6", "index": 3585}
{"task_id": "MBCPP/404", "completion": "    return (a < b) ? a : b;\n}", "unique_id": "MBCPP_404_7", "index": 3596}
{"task_id": "MBCPP/406", "completion": "    return (__builtin_popcount(x) % 2 == 0) ? \"Even Parity\" : \"Odd Parity\";\n}", "unique_id": "MBCPP_406_8", "index": 3607}
{"task_id": "MBCPP/408", "completion": "    auto compare = [&](pair<int, int>& a, pair<int, int>& b) {\n        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n    };\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compare)> minHeap(compare);\n    vector<vector<int>> result;\n\n    if (nums1.empty() || nums2.empty() || k == 0) return result;\n\n    for (int i = 0; i < nums1.size() && i < k; ++i) {\n        minHeap.emplace(i, 0);\n    }\n\n    while (k-- > 0 && !minHeap.empty()) {\n        auto [i, j] = minHeap.top();\n        minHeap.pop();\n        result.push_back({nums1[i], nums2[j]});\n        if (j + 1 < nums2.size()) {\n            minHeap.emplace(i, j + 1);\n        }\n    }\n\n    return result;\n}", "unique_id": "MBCPP_408_1", "index": 3610}
{"task_id": "MBCPP/409", "completion": "    int minProduct = INT_MAX;\n    for (const auto& tuple : list1) {\n        int product = tuple[0] * tuple[1];\n        if (product < minProduct) {\n            minProduct = product;\n        }\n    }\n    return minProduct;\n}", "unique_id": "MBCPP_409_5", "index": 3624}
{"task_id": "MBCPP/411", "completion": "    word[0] = toupper(word[0]);\n    for (size_t i = 0; i < word.length(); ++i) {\n        if (word[i] == '_') {\n            word[i + 1] = toupper(word[i + 1]);\n            word.erase(i, 1);\n        }\n    }\n    return word;\n}", "unique_id": "MBCPP_411_6", "index": 3635}
{"task_id": "MBCPP/412", "completion": "    vector<int> result;\n    for (int num : l) {\n        if (num % 2 == 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_412_8", "index": 3647}
{"task_id": "MBCPP/414", "completion": "    unordered_set<int> set1(list1.begin(), list1.end());\n    for (int num : list2) {\n        if (set1.find(num) != set1.end()) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_414_8", "index": 3657}
{"task_id": "MBCPP/415", "completion": "    if (arr.size() < 2)\n        return {};\n\n    int max1 = INT_MIN, max2 = INT_MIN;\n    int min1 = INT_MAX, min2 = INT_MAX;\n\n    for (int num : arr) {\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n    }\n\n    if (max1 * max2 > min1 * min2)\n        return {max1, max2};\n    else\n        return {min1, min2};\n}", "unique_id": "MBCPP_415_1", "index": 3660}
{"task_id": "MBCPP/416", "completion": "    if (n < 12) \n        return n;\n    return breaksum(n / 2) + breaksum(n / 3) + breaksum(n / 4);\n}", "unique_id": "MBCPP_416_9", "index": 3678}
{"task_id": "MBCPP/417", "completion": "    unordered_map<string, vector<string>> groups;\n    for (const auto& tup : input) {\n        if (!tup.empty()) {\n            groups[tup[0]].insert(groups[tup[0]].end(), tup.begin() + 1, tup.end());\n        }\n    }\n    \n    vector<vector<string>> result;\n    for (auto& [key, values] : groups) {\n        vector<string> group = {key};\n        group.insert(group.end(), values.begin(), values.end());\n        result.push_back(group);\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_417_7", "index": 3686}
{"task_id": "MBCPP/419", "completion": "    int sum = 0;\n    for (double num : list1) {\n        sum += round(num);\n    }\n    return sum * list1.size();\n}", "unique_id": "MBCPP_419_2", "index": 3691}
{"task_id": "MBCPP/420", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        int evenNumber = 2 * i;\n        sum += evenNumber * evenNumber * evenNumber;\n    }\n    return sum;\n}", "unique_id": "MBCPP_420_4", "index": 3703}
{"task_id": "MBCPP/423", "completion": "    vector<vector<int>> goldTable(m, vector<int>(n, 0));\n\n    for (int col = n - 1; col >= 0; col--) {\n        for (int row = 0; row < m; row++) {\n            int right = (col == n - 1) ? 0 : goldTable[row][col + 1];\n            int rightUp = (row == 0 || col == n - 1) ? 0 : goldTable[row - 1][col + 1];\n            int rightDown = (row == m - 1 || col == n - 1) ? 0 : goldTable[row + 1][col + 1];\n\n            goldTable[row][col] = gold[row][col] + max(right, max(rightUp, rightDown));\n        }\n    }\n\n    int maxGold = 0;\n    for (int i = 0; i < m; i++) {\n        maxGold = max(maxGold, goldTable[i][0]);\n    }\n\n    return maxGold;\n}", "unique_id": "MBCPP_423_3", "index": 3712}
{"task_id": "MBCPP/424", "completion": "    vector<string> result;\n    for(const auto& str : testTuple) {\n        if(!str.empty()) {\n            result.push_back(string(1, str.back()));\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_424_3", "index": 3722}
{"task_id": "MBCPP/426", "completion": "    vector<int> result;\n    copy_if(nums.begin(), nums.end(), back_inserter(result), [](int n) { return n % 2 != 0; });\n    return result;\n}", "unique_id": "MBCPP_426_6", "index": 3735}
{"task_id": "MBCPP/427", "completion": "    regex datePattern(R\"((\\d{4})-(\\d{2})-(\\d{2}))\");\n    return regex_replace(dt, datePattern, \"$3-$2-$1\");\n}", "unique_id": "MBCPP_427_1", "index": 3740}
{"task_id": "MBCPP/428", "completion": "    int n = myList.size();\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = myList[i];\n            int j;\n            for (j = i; j >= gap && myList[j - gap] > temp; j -= gap) {\n                myList[j] = myList[j - gap];\n            }\n            myList[j] = temp;\n        }\n    }\n    return myList;\n}", "unique_id": "MBCPP_428_10", "index": 3759}
{"task_id": "MBCPP/429", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] & testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_429_3", "index": 3762}
{"task_id": "MBCPP/430", "completion": "    return b * b - 4 * a * c;\n}", "unique_id": "MBCPP_430_8", "index": 3777}
{"task_id": "MBCPP/433", "completion": "    for(int i = 0; i < arr.size(); i++) {\n        if(number <= arr[i]) {\n            return \"No, entered number is less than those in the array\";\n        }\n    }\n    return \"Yes, the entered number is greater than those in the array\";\n}", "unique_id": "MBCPP_433_1", "index": 3780}
{"task_id": "MBCPP/434", "completion": "    regex pattern(\"ab+\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_434_1", "index": 3790}
{"task_id": "MBCPP/435", "completion": "    return abs(n) % 10;\n}", "unique_id": "MBCPP_435_6", "index": 3805}
{"task_id": "MBCPP/436", "completion": "    vector<int> result;\n    for (int num : list1) {\n        if (num < 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_436_1", "index": 3810}
{"task_id": "MBCPP/437", "completion": "    string result = \"\";\n    for (int i = 0; i < str1.size(); i++) {\n        if (i % 2 != 0) {\n            result += str1[i];\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_437_10", "index": 3829}
{"task_id": "MBCPP/438", "completion": "    map<pair<int, int>, int> pairCount;\n    int count = 0;\n\n    for (auto &pair : testList) {\n        pair<int, int> normalPair = make_pair(pair[0], pair[1]);\n        pair<int, int> reversePair = make_pair(pair[1], pair[0]);\n\n        if (pairCount[reversePair] > 0) {\n            count++;\n            pairCount[reversePair]--;\n        } else {\n            pairCount[normalPair]++;\n        }\n    }\n\n    return to_string(count);\n}", "unique_id": "MBCPP_438_9", "index": 3838}
{"task_id": "MBCPP/439", "completion": "    string result = \"\";\n    for (int num : l) {\n        result += to_string(num);\n    }\n    return stoi(result);\n}", "unique_id": "MBCPP_439_10", "index": 3849}
{"task_id": "MBCPP/441", "completion": "    return 6 * l * l;\n}", "unique_id": "MBCPP_441_3", "index": 3852}
{"task_id": "MBCPP/442", "completion": "    int positive_count = 0;\n    for (int num : nums) {\n        if (num > 0) {\n            positive_count++;\n        }\n    }\n    return static_cast<double>(positive_count) / nums.size();\n}", "unique_id": "MBCPP_442_8", "index": 3867}
{"task_id": "MBCPP/443", "completion": "    int largest = INT_MIN;\n    for(int num : list1) {\n        if(num < 0 && num > largest) {\n            largest = num;\n        }\n    }\n    return largest;\n}", "unique_id": "MBCPP_443_10", "index": 3879}
{"task_id": "MBCPP/444", "completion": "    vector<string> result;\n    for (auto &vec : testList) {\n        vector<int> trimmed(vec.begin() + k, vec.end() - k);\n        stringstream ss;\n        ss << \"(\";\n        for (size_t i = 0; i < trimmed.size(); ++i) {\n            ss << trimmed[i];\n            if (i != trimmed.size() - 1) {\n                ss << \", \";\n            }\n        }\n        ss << \")\";\n        result.push_back(ss.str());\n    }\n    return \"[\" + accumulate(next(result.begin()), result.end(), result[0], [](string a, string b) { return a + \", \" + b; }) + \"]\";\n}", "unique_id": "MBCPP_444_2", "index": 3881}
{"task_id": "MBCPP/445", "completion": "    vector<vector<int>> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        vector<int> temp;\n        for (size_t j = 0; j < testTup1[i].size(); ++j) {\n            temp.push_back(testTup1[i][j] * testTup2[i][j]);\n        }\n        result.push_back(temp);\n    }\n    return result;\n}", "unique_id": "MBCPP_445_3", "index": 3892}
{"task_id": "MBCPP/447", "completion": "    transform(nums.begin(), nums.end(), nums.begin(), [](int x) { return x * x * x; });\n    return nums;\n}", "unique_id": "MBCPP_447_7", "index": 3906}
{"task_id": "MBCPP/448", "completion": "    if (n == 0) return 3;\n    if (n == 1) return 0;\n    if (n == 2) return 2;\n\n    vector<int> perrin(n + 1);\n    perrin[0] = 3;\n    perrin[1] = 0;\n    perrin[2] = 2;\n\n    int sum = perrin[0] + perrin[1] + perrin[2];\n\n    for (int i = 3; i <= n; ++i) {\n        perrin[i] = perrin[i - 2] + perrin[i - 3];\n        sum += perrin[i];\n    }\n\n    return sum;\n}", "unique_id": "MBCPP_448_2", "index": 3911}
{"task_id": "MBCPP/449", "completion": "    int area = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2);\n    if (area == 0) {\n        return \"No\";\n    } else {\n        return \"Yes\";\n    }\n}", "unique_id": "MBCPP_449_3", "index": 3922}
{"task_id": "MBCPP/450", "completion": "    vector<string> result;\n    for(const auto& s : str) {\n        if(s.length() == l) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_450_8", "index": 3937}
{"task_id": "MBCPP/451", "completion": "    text1 = regex_replace(text1, regex(\"\\\\s+\"), \"\");\n    return text1;\n}", "unique_id": "MBCPP_451_1", "index": 3940}
{"task_id": "MBCPP/453", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0 && i % 2 == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_453_3", "index": 3952}
{"task_id": "MBCPP/454", "completion": "    regex pattern(\".*\\\\bz\\\\b.*\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_454_9", "index": 3968}
{"task_id": "MBCPP/455", "completion": "    return monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12;\n}", "unique_id": "MBCPP_455_1", "index": 3970}
{"task_id": "MBCPP/456", "completion": "    for (auto &str : stringlist) {\n        reverse(str.begin(), str.end());\n    }\n    return stringlist;\n}", "unique_id": "MBCPP_456_7", "index": 3986}
{"task_id": "MBCPP/458", "completion": "    return l * b;\n}", "unique_id": "MBCPP_458_8", "index": 3997}
{"task_id": "MBCPP/459", "completion": "    return regex_replace(str1, regex(\"[A-Z]+\"), \"\");\n}", "unique_id": "MBCPP_459_7", "index": 4006}
{"task_id": "MBCPP/460", "completion": "    vector<int> result;\n    for (const auto& sublist : lst) {\n        if (!sublist.empty()) {\n            result.push_back(sublist[0]);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_460_1", "index": 4010}
{"task_id": "MBCPP/461", "completion": "    int count = 0;\n    for (char c : str) {\n        if (isupper(c)) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_461_4", "index": 4023}
{"task_id": "MBCPP/463", "completion": "    int n = arr.size();\n    if (n == 0) return 0;\n\n    int max_ending_here = arr[0];\n    int min_ending_here = arr[0];\n    int max_so_far = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < 0) {\n            swap(max_ending_here, min_ending_here);\n        }\n\n        max_ending_here = max(arr[i], max_ending_here * arr[i]);\n        min_ending_here = min(arr[i], min_ending_here * arr[i]);\n\n        max_so_far = max(max_so_far, max_ending_here);\n    }\n\n    return max_so_far;\n}", "unique_id": "MBCPP_463_3", "index": 4032}
{"task_id": "MBCPP/464", "completion": "    for (const auto& [key, value] : dict) {\n        if (value != n) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_464_3", "index": 4042}
{"task_id": "MBCPP/466", "completion": "    int left = 0, right = n - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] < arr[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}", "unique_id": "MBCPP_466_3", "index": 4052}
{"task_id": "MBCPP/467", "completion": "    int octalNum = 0, placeValue = 1;\n\n    while (decinum > 0) {\n        int remainder = decinum % 8;\n        octalNum += remainder * placeValue;\n        decinum /= 8;\n        placeValue *= 10;\n    }\n\n    return octalNum;\n}", "unique_id": "MBCPP_467_2", "index": 4061}
{"task_id": "MBCPP/468", "completion": "    vector<long long> dp(n, 0);\n    long long result = 0;\n\n    for (int i = 0; i < n; i++) {\n        dp[i] = arr[i];\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j]) {\n                dp[i] = max(dp[i], dp[j] * arr[i]);\n            }\n        }\n        result = max(result, dp[i]);\n    }\n\n    return result;\n}", "unique_id": "MBCPP_468_10", "index": 4079}
{"task_id": "MBCPP/469", "completion": "    int n = price.size();\n    if (n == 0 || k == 0) return 0;\n\n    // If k is greater than n/2, then it's equivalent to unlimited transactions.\n    if (k >= n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i) {\n            if (price[i] > price[i - 1]) {\n                maxProfit += price[i] - price[i - 1];\n            }\n        }\n        return maxProfit;\n    }\n\n    // Create a 2D dp array to store the maximum profit\n    vector<vector<int>> dp(k + 1, vector<int>(n, 0));\n\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -price[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = max(dp[i][j - 1], price[j] + maxDiff);\n            maxDiff = max(maxDiff, dp[i - 1][j] - price[j]);\n        }\n    }\n\n    return dp[k][n - 1];\n}", "unique_id": "MBCPP_469_1", "index": 4080}
{"task_id": "MBCPP/470", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup.size() - 1; ++i) {\n        result.push_back(testTup[i] + testTup[i + 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_470_2", "index": 4091}
{"task_id": "MBCPP/471", "completion": "    long long product = 1;\n    for (int i = 0; i < lens; ++i) {\n        product = (product * arr[i]) % n;\n    }\n    return product % n;\n}", "unique_id": "MBCPP_471_10", "index": 4109}
{"task_id": "MBCPP/472", "completion": "    if (l.empty()) return false;\n    sort(l.begin(), l.end());\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] != l[i - 1] + 1) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_472_4", "index": 4113}
{"task_id": "MBCPP/474", "completion": "    size_t pos = str1.find(ch);\n    while (pos != string::npos) {\n        str1.replace(pos, ch.length(), newch);\n        pos = str1.find(ch, pos + newch.length());\n    }\n    return str1;\n}", "unique_id": "MBCPP_474_4", "index": 4123}
{"task_id": "MBCPP/476", "completion": "    if (nums.empty()) return 0;\n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    return min_val + max_val;\n}", "unique_id": "MBCPP_476_9", "index": 4138}
{"task_id": "MBCPP/477", "completion": "    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    return str;\n}", "unique_id": "MBCPP_477_2", "index": 4141}
{"task_id": "MBCPP/478", "completion": "    string result;\n    for (char c : str1) {\n        if (!islower(c)) {\n            result += c;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_478_5", "index": 4154}
{"task_id": "MBCPP/479", "completion": "    while (n >= 10)\n        n /= 10;\n    return n;\n}", "unique_id": "MBCPP_479_10", "index": 4169}
{"task_id": "MBCPP/480", "completion": "    vector<int> count(256, 0);\n    for (char ch : str1) {\n        if (ch != ' ') {\n            count[ch]++;\n        }\n    }\n    \n    int maxCount = 0;\n    char result;\n    for (char ch : str1) {\n        if (ch != ' ' && count[ch] > maxCount) {\n            maxCount = count[ch];\n            result = ch;\n        }\n    }\n    return string(1, result);\n}", "unique_id": "MBCPP_480_2", "index": 4171}
{"task_id": "MBCPP/481", "completion": "    if (sum == 0)\n        return true;\n    if (n == 0)\n        return false;\n\n    if (set[n - 1] > sum)\n        return isSubsetSum(set, n - 1, sum);\n\n    return isSubsetSum(set, n - 1, sum) || isSubsetSum(set, n - 1, sum - set[n - 1]);\n}", "unique_id": "MBCPP_481_7", "index": 4186}
{"task_id": "MBCPP/482", "completion": "    regex pattern(\"[A-Z][a-z]+\");\n    smatch matches;\n    if (regex_search(text, matches, pattern)) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "unique_id": "MBCPP_482_7", "index": 4196}
{"task_id": "MBCPP/483", "completion": "    int factorial = 1;\n    for (int i = 1; ; ++i) {\n        factorial *= i;\n        if (factorial % x == 0) {\n            return i;\n        }\n    }\n}", "unique_id": "MBCPP_483_2", "index": 4201}
{"task_id": "MBCPP/484", "completion": "    set<vector<string>> testSet2(testList2.begin(), testList2.end());\n    vector<vector<string>> result;\n    for (const auto& tuple : testList1) {\n        if (testSet2.find(tuple) == testSet2.end()) {\n            result.push_back(tuple);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_484_6", "index": 4215}
{"task_id": "MBCPP/485", "completion": "    auto isPalindrome = [](int num) {\n        string s = to_string(num);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        return s == rev_s;\n    };\n    \n    int largest = -1;\n    for (int num : a) {\n        if (isPalindrome(num)) {\n            largest = max(largest, num);\n        }\n    }\n    \n    return largest;\n}", "unique_id": "MBCPP_485_2", "index": 4221}
{"task_id": "MBCPP/486", "completion": "    double q = 1 - p;\n    double prob = 1.0;\n    for (int i = 0; i < k; ++i) {\n        prob *= (n - i) * p / (i + 1);\n    }\n    for (int i = 0; i < n - k; ++i) {\n        prob *= q;\n    }\n    return prob;\n}", "unique_id": "MBCPP_486_8", "index": 4237}
{"task_id": "MBCPP/487", "completion": "    sort(tup.begin(), tup.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.back() < b.back();\n    });\n    return tup;\n}", "unique_id": "MBCPP_487_2", "index": 4241}
{"task_id": "MBCPP/488", "completion": "    const double PI = 3.14159265358979323846;\n    double side = static_cast<double>(a);\n    double apothem = side / (2 * tan(PI / 5));\n    return (5 * side * apothem) / 2;\n}", "unique_id": "MBCPP_488_1", "index": 4250}
{"task_id": "MBCPP/489", "completion": "    int largest = *max_element(arr.begin(), arr.end());\n    return count(arr.begin(), arr.end(), largest);\n}", "unique_id": "MBCPP_489_1", "index": 4260}
{"task_id": "MBCPP/491", "completion": "    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += a * pow(r, i);\n    }\n    return sum;\n}", "unique_id": "MBCPP_491_10", "index": 4279}
{"task_id": "MBCPP/492", "completion": "    int left = 0, right = itemList.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (itemList[mid] == item) {\n            return true;\n        }\n        if (itemList[mid] < item) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_492_4", "index": 4283}
{"task_id": "MBCPP/493", "completion": "    vector<vector<vector<double>>> hexagons;\n    double dx = 1.5 * radius;\n    double dy = sqrt(3) * radius;\n    \n    for (int y = starty; y <= endy; y++) {\n        for (int x = startx; x <= endx; x++) {\n            double cx = x * dx;\n            double cy = y * dy;\n            \n            if (x % 2 != 0) {\n                cy += dy / 2.0;\n            }\n            \n            vector<vector<double>> hexagon;\n            for (int i = 0; i < 6; ++i) {\n                double angle = M_PI / 3.0 * i;\n                double px = cx + radius * cos(angle);\n                double py = cy + radius * sin(angle);\n                hexagon.push_back({px, py});\n            }\n            hexagon.push_back(hexagon[0]);\n            hexagons.push_back(hexagon);\n        }\n    }\n    \n    return hexagons;\n}", "unique_id": "MBCPP_493_7", "index": 4296}
{"task_id": "MBCPP/494", "completion": "    int result = 0;\n    for (int bit : testTup) {\n        result = (result << 1) | bit;\n    }\n    return to_string(result);\n}", "unique_id": "MBCPP_494_8", "index": 4307}
{"task_id": "MBCPP/495", "completion": "    return regex_replace(str1, regex(\"[a-z]+\"), \"\");\n}", "unique_id": "MBCPP_495_3", "index": 4312}
{"task_id": "MBCPP/496", "completion": "    priority_queue<int> maxHeap;\n    for(int num : nums) {\n        maxHeap.push(num);\n        if(maxHeap.size() > n) {\n            maxHeap.pop();\n        }\n    }\n    vector<int> result;\n    while(!maxHeap.empty()) {\n        result.push_back(maxHeap.top());\n        maxHeap.pop();\n    }\n    sort(result.begin(), result.end());\n    return result;\n}", "unique_id": "MBCPP_496_2", "index": 4321}
{"task_id": "MBCPP/497", "completion": "    double l = sqrt(r * r + h * h);\n    double area = M_PI * r * (r + l);\n    return area;\n}", "unique_id": "MBCPP_497_3", "index": 4332}
{"task_id": "MBCPP/498", "completion": "    while (y != 0) {\n        int temp = y;\n        y = x % y;\n        x = temp;\n    }\n    return x;\n}", "unique_id": "MBCPP_498_6", "index": 4345}
{"task_id": "MBCPP/499", "completion": "    return 2 * r;\n}", "unique_id": "MBCPP_499_1", "index": 4350}
{"task_id": "MBCPP/500", "completion": "    string result = \"  \";\n    for (const string& s : list) {\n        result += s + \" \";\n    }\n    if (!result.empty() && result.back() == ' ') {\n        result.pop_back();\n    }\n    return result;\n}", "unique_id": "MBCPP_500_2", "index": 4361}
{"task_id": "MBCPP/501", "completion": "    int gcd = __gcd(x, y);\n    int count = 0;\n    for (int i = 1; i <= gcd; ++i) {\n        if (gcd % i == 0) {\n            ++count;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_501_2", "index": 4371}
{"task_id": "MBCPP/502", "completion": "    return n % m;\n}", "unique_id": "MBCPP_502_6", "index": 4385}
{"task_id": "MBCPP/503", "completion": "    vector<int> result;\n    for (int i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] + nums[i + 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_503_4", "index": 4393}
{"task_id": "MBCPP/504", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += i * i * i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_504_8", "index": 4407}
{"task_id": "MBCPP/505", "completion": "    int count = 0;  // Count of non-zero elements\n\n    // Traverse the array. If element encountered is non-zero, then\n    // replace the element at index 'count' with this element\n    for (int i = 0; i < a.size(); i++) {\n        if (a[i] != 0) {\n            a[count++] = a[i]; // here count is incremented\n        }\n    }\n\n    // Now all non-zero elements have been shifted to front and 'count' is\n    // set as index of first 0. Make all elements 0 from count to end.\n    while (count < a.size()) {\n        a[count++] = 0;\n    }\n\n    return a;\n}", "unique_id": "MBCPP_505_8", "index": 4417}
{"task_id": "MBCPP/506", "completion": "    int result = 1;\n    for (int i = 0; i < k; i++) {\n        result *= (n - i);\n    }\n    return result;\n}", "unique_id": "MBCPP_506_4", "index": 4423}
{"task_id": "MBCPP/507", "completion": "    unordered_set<string> removeSet(removewords.begin(), removewords.end());\n    vector<string> result;\n    for (const auto& word : list1) {\n        if (removeSet.find(word) == removeSet.end()) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_507_6", "index": 4435}
{"task_id": "MBCPP/508", "completion": "    unordered_set<string> set_l1(l1.begin(), l1.end());\n    vector<string> common_elements;\n\n    for (const auto& item : l2) {\n        if (set_l1.find(item) != set_l1.end()) {\n            common_elements.push_back(item);\n        }\n    }\n\n    auto it = l1.begin();\n    for (const auto& item : common_elements) {\n        it = find(it, l1.end(), item);\n        if (it == l1.end()) {\n            return false;\n        }\n        ++it;\n    }\n\n    return true;\n}", "unique_id": "MBCPP_508_8", "index": 4447}
{"task_id": "MBCPP/509", "completion": "    int sum = 0;\n    int count = 0;\n    for (int i = 1; i <= n; i += 2) {\n        sum += i;\n        count++;\n    }\n    return sum / count;\n}", "unique_id": "MBCPP_509_1", "index": 4450}
{"task_id": "MBCPP/510", "completion": "    int n = arr.size();\n    int count = 0;\n    \n    // Sort the array to use two pointer technique\n    sort(arr.begin(), arr.end());\n    \n    // Use two pointers to find all subsequences with product less than k\n    for (int i = 0; i < n; ++i) {\n        // If the current element itself is greater or equal to k, skip it\n        if (arr[i] >= k) break;\n        \n        int product = arr[i];\n        count++;  // Single element subsequence\n        \n        for (int j = i + 1; j < n; ++j) {\n            if (product * arr[j] < k) {\n                product *= arr[j];\n                count++;\n            } else {\n                break;\n            }\n        }\n    }\n    \n    return count;\n}", "unique_id": "MBCPP_510_5", "index": 4464}
{"task_id": "MBCPP/511", "completion": "    if (num <= 1) return num;\n    int sum = INT_MAX;\n    for (int i = 1; i * i <= num; ++i) {\n        if (num % i == 0) {\n            int factor1 = i;\n            int factor2 = num / i;\n            sum = min(sum, factor1 + factor2);\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_511_2", "index": 4471}
{"task_id": "MBCPP/514", "completion": "    int sum = 0;\n    for(int num : testTup) {\n        sum += num;\n    }\n    return sum;\n}", "unique_id": "MBCPP_514_10", "index": 4489}
{"task_id": "MBCPP/515", "completion": "    vector<bool> dp(m, false);\n    dp[0] = true;\n\n    for (int i = 0; i < n; ++i) {\n        vector<bool> temp(dp);\n        for (int j = 0; j < m; ++j) {\n            if (dp[j]) {\n                temp[(j + arr[i]) % m] = true;\n            }\n        }\n        dp = temp;\n    }\n\n    return dp[0];\n}", "unique_id": "MBCPP_515_6", "index": 4495}
{"task_id": "MBCPP/516", "completion": "    if (nums.empty())\n        return nums;\n\n    int maxNum = *max_element(nums.begin(), nums.end());\n    int exp = 1;\n\n    while (maxNum / exp > 0) {\n        vector<int> output(nums.size());\n        vector<int> count(10, 0);\n\n        for (int num : nums)\n            count[(num / exp) % 10]++;\n\n        for (int i = 1; i < 10; i++)\n            count[i] += count[i - 1];\n\n        for (int i = nums.size() - 1; i >= 0; i--) {\n            output[count[(nums[i] / exp) % 10] - 1] = nums[i];\n            count[(nums[i] / exp) % 10]--;\n        }\n\n        nums = output;\n        exp *= 10;\n    }\n\n    return nums;\n}", "unique_id": "MBCPP_516_10", "index": 4509}
{"task_id": "MBCPP/517", "completion": "    int largest = INT_MIN;\n    for (int num : list1) {\n        if (num > 0 && num > largest) {\n            largest = num;\n        }\n    }\n    return largest == INT_MIN ? 0 : largest;\n}", "unique_id": "MBCPP_517_3", "index": 4512}
{"task_id": "MBCPP/518", "completion": "    return sqrt(num);\n}", "unique_id": "MBCPP_518_4", "index": 4523}
{"task_id": "MBCPP/519", "completion": "    return (pow(num, 3) / (6 * sqrt(2)));\n}", "unique_id": "MBCPP_519_1", "index": 4530}
{"task_id": "MBCPP/520", "completion": "    auto lcm = [](int a, int b) {\n        return (a / __gcd(a, b)) * b;\n    };\n    return accumulate(l.begin(), l.end(), 1, lcm);\n}", "unique_id": "MBCPP_520_9", "index": 4548}
{"task_id": "MBCPP/521", "completion": "    return (x != y) && (y != z) && (x != z);\n}", "unique_id": "MBCPP_521_3", "index": 4552}
{"task_id": "MBCPP/522", "completion": "    int n = arr.size();\n    if (n == 0) return 0;\n\n    vector<int> inc(n, 1), dec(n, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && inc[i] < inc[j] + 1) {\n                inc[i] = inc[j] + 1;\n            }\n        }\n    }\n\n    for (int i = n - 2; i >= 0; i--) {\n        for (int j = n - 1; j > i; j--) {\n            if (arr[i] > arr[j] && dec[i] < dec[j] + 1) {\n                dec[i] = dec[j] + 1;\n            }\n        }\n    }\n\n    int max_len = 0;\n    for (int i = 0; i < n; i++) {\n        max_len = max(max_len, inc[i] + dec[i] - 1);\n    }\n\n    return max_len;\n}", "unique_id": "MBCPP_522_1", "index": 4560}
{"task_id": "MBCPP/523", "completion": "    vector<string> errors;\n    \n    auto has_upper = [](const string &s) {\n        return any_of(s.begin(), s.end(), ::isupper);\n    };\n    \n    auto has_lower = [](const string &s) {\n        return any_of(s.begin(), s.end(), ::islower);\n    };\n    \n    auto has_digit = [](const string &s) {\n        return any_of(s.begin(), s.end(), ::isdigit);\n    };\n    \n    if (!has_upper(str1)) {\n        errors.push_back(\"String must have 1 upper case character.\");\n    }\n    \n    if (!has_lower(str1)) {\n        errors.push_back(\"String must have 1 lower case character.\");\n    }\n    \n    if (!has_digit(str1)) {\n        errors.push_back(\"String must have 1 number.\");\n    }\n    \n    if (str1.length() < 8) {\n        errors.push_back(\"String length should be atleast 8.\");\n    }\n    \n    if (errors.empty()) {\n        errors.push_back(\"Valid string.\");\n    }\n    \n    return errors;\n}", "unique_id": "MBCPP_523_9", "index": 4578}
{"task_id": "MBCPP/524", "completion": "    vector<int> msis(arr.begin(), arr.end());\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && msis[i] < msis[j] + arr[i]) {\n                msis[i] = msis[j] + arr[i];\n            }\n        }\n    }\n\n    return *max_element(msis.begin(), msis.end());\n}", "unique_id": "MBCPP_524_4", "index": 4583}
{"task_id": "MBCPP/525", "completion": "    if (line1.size() != line2.size()) \n        return false;\n    if (line1.size() == 2) {\n        return line1[0] * line2[1] == line1[1] * line2[0];\n    } else if (line1.size() == 3) {\n        return line1[0] * line2[1] == line1[1] * line2[0] && line1[0] * line2[2] == line1[2] * line2[0];\n    }\n    return false;\n}", "unique_id": "MBCPP_525_4", "index": 4593}
{"task_id": "MBCPP/526", "completion": "    int n = str1.size();\n    if (n == 0) return str1; // Empty string case\n\n    bool inWord = false;\n    for (int i = 0; i < n; i++) {\n        if (isalpha(str1[i])) {\n            if (!inWord) {\n                str1[i] = toupper(str1[i]); // Capitalize first letter of the word\n                inWord = true;\n            } else if (i == n - 1 || !isalpha(str1[i + 1])) {\n                str1[i] = toupper(str1[i]); // Capitalize last letter of the word\n                inWord = false;\n            }\n        } else {\n            inWord = false; // Non-alphabetic character resets word state\n        }\n    }\n    return str1;\n}", "unique_id": "MBCPP_526_6", "index": 4605}
{"task_id": "MBCPP/527", "completion": "    unordered_map<int, int> freq;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int complement = sum - arr[i];\n        if (freq.find(complement) != freq.end()) {\n            count += freq[complement];\n        }\n        freq[arr[i]]++;\n    }\n\n    return count;\n}", "unique_id": "MBCPP_527_5", "index": 4614}
{"task_id": "MBCPP/529", "completion": "    if (n == 0)\n        return 2;\n    if (n == 1)\n        return 1;\n    return jacobsthalLucas(n - 1) + 2 * jacobsthalLucas(n - 2);\n}", "unique_id": "MBCPP_529_9", "index": 4628}
{"task_id": "MBCPP/530", "completion": "    int negative_count = 0;\n    for (int num : nums) {\n        if (num < 0) {\n            negative_count++;\n        }\n    }\n    return static_cast<double>(negative_count) / nums.size();\n}", "unique_id": "MBCPP_530_2", "index": 4631}
{"task_id": "MBCPP/531", "completion": "    vector<int> dp(v + 1, INT_MAX);\n    dp[0] = 0;\n\n    for (int i = 1; i <= v; i++) {\n        for (int j = 0; j < m; j++) {\n            if (coins[j] <= i && dp[i - coins[j]] != INT_MAX) {\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n    }\n\n    return dp[v] == INT_MAX ? -1 : dp[v];\n}", "unique_id": "MBCPP_531_4", "index": 4643}
{"task_id": "MBCPP/532", "completion": "    if (str1.length() != str2.length()) {\n        return false;\n    }\n    sort(str1.begin(), str1.end());\n    sort(str2.begin(), str2.end());\n    return str1 == str2;\n}", "unique_id": "MBCPP_532_5", "index": 4654}
{"task_id": "MBCPP/534", "completion": "    vector<int> result;\n    size_t pos = text.find(pattern);\n    if (pos != string::npos) {\n        result.push_back(pos);\n        result.push_back(pos + pattern.length() - 1);\n    }\n    return result;\n}", "unique_id": "MBCPP_534_7", "index": 4666}
{"task_id": "MBCPP/535", "completion": "    return M_PI * r * r;\n}", "unique_id": "MBCPP_535_2", "index": 4671}
{"task_id": "MBCPP/536", "completion": "    vector<int> result;\n    for (int i = 0; i < list.size(); i += n) {\n        result.push_back(list[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_536_2", "index": 4681}
{"task_id": "MBCPP/537", "completion": "    unordered_set<string> seen;\n    istringstream iss(str1);\n    string word;\n    while (iss >> word) {\n        if (seen.find(word) != seen.end()) {\n            return word;\n        }\n        seen.insert(word);\n    }\n    return \"None\";\n}", "unique_id": "MBCPP_537_2", "index": 4691}
{"task_id": "MBCPP/538", "completion": "    vector<string> result;\n    for (char ch : str1) {\n        result.push_back(string(1, ch));\n    }\n    return result;\n}", "unique_id": "MBCPP_538_8", "index": 4707}
{"task_id": "MBCPP/540", "completion": "    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    \n    int maxFreq = INT_MIN, minFreq = INT_MAX;\n    for (auto& pair : freq) {\n        maxFreq = max(maxFreq, pair.second);\n        minFreq = min(minFreq, pair.second);\n    }\n    \n    return maxFreq - minFreq;\n}", "unique_id": "MBCPP_540_9", "index": 4718}
{"task_id": "MBCPP/541", "completion": "    int sum = 1;\n    for (int i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n            if (i == (n / i))\n                sum += i;\n            else\n                sum += (i + n / i);\n        }\n    }\n    return sum > n;\n}", "unique_id": "MBCPP_541_9", "index": 4728}
{"task_id": "MBCPP/542", "completion": "    return regex_replace(text, regex(\"[ ,.]\"), \":\");\n}", "unique_id": "MBCPP_542_9", "index": 4738}
{"task_id": "MBCPP/543", "completion": "    long long sum = (long long)num1 + (long long)num2;\n    int digits = 0;\n    while (sum != 0) {\n        digits++;\n        sum /= 10;\n    }\n    return digits;\n}", "unique_id": "MBCPP_543_9", "index": 4748}
{"task_id": "MBCPP/544", "completion": "    string result;\n    for (const auto& sublist : testList) {\n        for (const auto& item : sublist) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += item;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_544_3", "index": 4752}
{"task_id": "MBCPP/545", "completion": "    int num_bits = sizeof(n) * 8;\n    int first_bit_mask = 1;\n    int last_bit_mask = 1 << (num_bits - 1);\n    return n ^ (first_bit_mask | last_bit_mask);\n}", "unique_id": "MBCPP_545_4", "index": 4763}
{"task_id": "MBCPP/547", "completion": "    auto hammingDistance = [](int x, int y) {\n        int xor_val = x ^ y;\n        int distance = 0;\n        while (xor_val) {\n            distance += xor_val & 1;\n            xor_val >>= 1;\n        }\n        return distance;\n    };\n\n    int total_distance = 0;\n    for (int i = 0; i < n; ++i) {\n        total_distance += hammingDistance(i, i + 1);\n    }\n    return total_distance;\n}", "unique_id": "MBCPP_547_7", "index": 4776}
{"task_id": "MBCPP/548", "completion": "    if (arr.empty()) return 0;\n    vector<int> lis(arr.size(), 1);\n    for (int i = 1; i < arr.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && lis[i] < lis[j] + 1) {\n                lis[i] = lis[j] + 1;\n            }\n        }\n    }\n    return *max_element(lis.begin(), lis.end());\n}", "unique_id": "MBCPP_548_1", "index": 4780}
{"task_id": "MBCPP/549", "completion": "    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        int oddNum = 2 * i + 1;\n        sum += pow(oddNum, 5);\n    }\n    return sum;\n}", "unique_id": "MBCPP_549_7", "index": 4796}
{"task_id": "MBCPP/550", "completion": "    if (low == high)\n        return arr[low];\n    if (high == low + 1)\n        return max(arr[low], arr[high]);\n    int mid = (low + high) / 2;\n    if (arr[mid] > arr[mid + 1])\n        return arr[mid];\n    if (arr[mid] < arr[mid - 1])\n        return arr[mid - 1];\n    if (arr[low] > arr[mid])\n        return findMax(arr, low, mid - 1);\n    return findMax(arr, mid + 1, high);\n}", "unique_id": "MBCPP_550_2", "index": 4801}
{"task_id": "MBCPP/551", "completion": "    vector<int> result;\n    for (const auto& row : list1) {\n        if (n < row.size()) {\n            result.push_back(row[n]);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_551_9", "index": 4818}
{"task_id": "MBCPP/552", "completion": "    if (seqNums.size() <= 1)\n        return \"Linear Sequence\";\n\n    int diff = seqNums[1] - seqNums[0];\n    for (size_t i = 2; i < seqNums.size(); ++i) {\n        if (seqNums[i] - seqNums[i - 1] != diff)\n            return \"Non Linear Sequence\";\n    }\n    return \"Linear Sequence\";\n}", "unique_id": "MBCPP_552_1", "index": 4820}
{"task_id": "MBCPP/553", "completion": "    int integerPart = testTup[0];\n    int decimalPart = testTup[1];\n    double divisor = pow(10, to_string(decimalPart).length());\n    return integerPart + decimalPart / divisor;\n}", "unique_id": "MBCPP_553_5", "index": 4834}
{"task_id": "MBCPP/554", "completion": "    vector<int> result;\n    for(int num : list) {\n        if(num % 2 != 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_554_1", "index": 4840}
{"task_id": "MBCPP/555", "completion": "    int sum_of_cubes = 0;\n    int sum_of_naturals = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum_of_cubes += i * i * i;\n        sum_of_naturals += i;\n    }\n    return sum_of_cubes - sum_of_naturals;\n}", "unique_id": "MBCPP_555_4", "index": 4853}
{"task_id": "MBCPP/556", "completion": "    int odd_count = 0, even_count = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] % 2 == 0)\n            even_count++;\n        else\n            odd_count++;\n    }\n    return odd_count * even_count;\n}", "unique_id": "MBCPP_556_1", "index": 4860}
{"task_id": "MBCPP/557", "completion": "    for (char& c : str) {\n        if (isupper(c))\n            c = tolower(c);\n        else if (islower(c))\n            c = toupper(c);\n    }\n    return str;\n}", "unique_id": "MBCPP_557_5", "index": 4874}
{"task_id": "MBCPP/558", "completion": "    int distance = 0;\n    while (n1 > 0 || n2 > 0) {\n        distance += abs((n1 % 10) - (n2 % 10));\n        n1 /= 10;\n        n2 /= 10;\n    }\n    return distance;\n}", "unique_id": "MBCPP_558_10", "index": 4889}
{"task_id": "MBCPP/559", "completion": "    int max_so_far = INT_MIN, max_ending_here = 0;\n    for (int i = 0; i < size; i++) {\n        max_ending_here = max_ending_here + a[i];\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n        if (max_ending_here < 0)\n            max_ending_here = 0;\n    }\n    return max_so_far;\n}", "unique_id": "MBCPP_559_1", "index": 4890}
{"task_id": "MBCPP/560", "completion": "    set<int> resultSet(testTup1.begin(), testTup1.end());\n    resultSet.insert(testTup2.begin(), testTup2.end());\n    return vector<int>(resultSet.begin(), resultSet.end());\n}", "unique_id": "MBCPP_560_3", "index": 4902}
{"task_id": "MBCPP/562", "completion": "    int maxLength = 0;\n    for (const auto& sublist : lst) {\n        if (sublist.size() > maxLength) {\n            maxLength = sublist.size();\n        }\n    }\n    return maxLength;\n}", "unique_id": "MBCPP_562_10", "index": 4919}
{"task_id": "MBCPP/563", "completion": "    vector<string> result;\n    stringstream ss(text);\n    string word;\n    while (getline(ss, word, ',')) {\n        size_t start = word.find_first_of('\"') + 1;\n        size_t end = word.find_last_of('\"');\n        result.push_back(word.substr(start, end - start));\n    }\n    return result;\n}", "unique_id": "MBCPP_563_4", "index": 4923}
{"task_id": "MBCPP/564", "completion": "    int count = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            if(arr[i] != arr[j]) {\n                ++count;\n            }\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_564_9", "index": 4938}
{"task_id": "MBCPP/565", "completion": "    vector<string> result;\n    for (char c : word) {\n        result.push_back(string(1, c));\n    }\n    return result;\n}", "unique_id": "MBCPP_565_8", "index": 4947}
{"task_id": "MBCPP/566", "completion": "    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}", "unique_id": "MBCPP_566_10", "index": 4959}
{"task_id": "MBCPP/567", "completion": "    for (int i = 1; i < list1.size(); i++) {\n        if (list1[i] < list1[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_567_2", "index": 4961}
{"task_id": "MBCPP/569", "completion": "    for(auto &sublist : list1) {\n        sort(sublist.begin(), sublist.end());\n    }\n    return list1;\n}", "unique_id": "MBCPP_569_8", "index": 4977}
{"task_id": "MBCPP/570", "completion": "    for (string &str : list1) {\n        for (const string &ch : charlist) {\n            size_t pos;\n            while ((pos = str.find(ch)) != string::npos) {\n                str.erase(pos, ch.length());\n            }\n        }\n    }\n    return list1;\n}", "unique_id": "MBCPP_570_6", "index": 4985}
{"task_id": "MBCPP/571", "completion": "    sort(arr.begin(), arr.end());\n    int sum = 0;\n    for (int i = n - 1; i > 0; i--) {\n        if (arr[i] - arr[i - 1] < k) {\n            sum += arr[i] + arr[i - 1];\n            i--;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_571_9", "index": 4998}
{"task_id": "MBCPP/572", "completion": "    unordered_map<int, int> count;\n    for(int num : nums) {\n        count[num]++;\n    }\n    \n    vector<int> result;\n    for(int num : nums) {\n        if(count[num] == 1) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_572_2", "index": 5001}
{"task_id": "MBCPP/573", "completion": "    unordered_set<int> unique_numbers(listData.begin(), listData.end());\n    int product = 1;\n    for (int num : unique_numbers) {\n        product *= num;\n    }\n    return product;\n}", "unique_id": "MBCPP_573_6", "index": 5015}
{"task_id": "MBCPP/574", "completion": "    double surfaceArea = 2 * M_PI * r * (r + h);\n    return surfaceArea;\n}", "unique_id": "MBCPP_574_8", "index": 5027}
{"task_id": "MBCPP/575", "completion": "    int count = 0;\n    for (int i = l; i <= r; ++i) {\n        if (i % n != 0) {\n            count++;\n        }\n        if (count == a) {\n            return i;\n        }\n    }\n    return -1;  // In case the required count is not met within the range\n}", "unique_id": "MBCPP_575_1", "index": 5030}
{"task_id": "MBCPP/576", "completion": "    for (int i = 0; i <= n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++) {\n            if (a[i + j] != b[j])\n                break;\n        }\n        if (j == m)\n            return true;\n    }\n    return false;\n}", "unique_id": "MBCPP_576_10", "index": 5049}
{"task_id": "MBCPP/577", "completion": "    if (n >= 5)\n        return 0;\n    int factorial = 1;\n    for (int i = 1; i <= n; i++) {\n        factorial *= i;\n    }\n    return factorial % 10;\n}", "unique_id": "MBCPP_577_2", "index": 5051}
{"task_id": "MBCPP/578", "completion": "    vector<int> result;\n    for (size_t i = 0; i < list1.size(); ++i) {\n        result.push_back(list1[i]);\n        result.push_back(list2[i]);\n        result.push_back(list3[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_578_1", "index": 5060}
{"task_id": "MBCPP/579", "completion": "    set<int> set1(testTup1.begin(), testTup1.end());\n    set<int> set2(testTup2.begin(), testTup2.end());\n    vector<int> result;\n\n    for (int num : set1) {\n        if (set2.find(num) == set2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    for (int num : set2) {\n        if (set1.find(num) == set1.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}", "unique_id": "MBCPP_579_10", "index": 5079}
{"task_id": "MBCPP/581", "completion": "    int base_area = b * b;\n    int slant_height = sqrt((b / 2.0) * (b / 2.0) + s * s);\n    int lateral_area = 2 * b * slant_height;\n    return base_area + lateral_area;\n}", "unique_id": "MBCPP_581_1", "index": 5080}
{"task_id": "MBCPP/582", "completion": "    return dict1.empty();\n}", "unique_id": "MBCPP_582_1", "index": 5090}
{"task_id": "MBCPP/583", "completion": "    if (num <= 1)\n        return 1;\n\n    vector<int> catalan(num + 1, 0);\n    catalan[0] = catalan[1] = 1;\n\n    for (int i = 2; i <= num; i++) {\n        for (int j = 0; j < i; j++) {\n            catalan[i] += catalan[j] * catalan[i - 1 - j];\n        }\n    }\n    \n    return catalan[num];\n}", "unique_id": "MBCPP_583_1", "index": 5100}
{"task_id": "MBCPP/584", "completion": "    vector<string> result;\n    regex adverb_regex(\"\\\\b\\\\w+ly\\\\b\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), adverb_regex);\n    auto words_end = sregex_iterator();\n\n    for (sregex_iterator i = words_begin; i != words_end; ++i) {\n        smatch match = *i;\n        result.push_back(to_string(match.position()) + \"-\" + to_string(match.position() + match.length()) + \": \" + match.str());\n    }\n\n    return result.empty() ? \"\" : result[0];\n}", "unique_id": "MBCPP_584_10", "index": 5119}
{"task_id": "MBCPP/586", "completion": "    vector<int> result;\n    for (int i = k; i < n; ++i) {\n        result.push_back(a[i]);\n    }\n    for (int i = 0; i < k; ++i) {\n        result.push_back(a[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_586_1", "index": 5120}
{"task_id": "MBCPP/587", "completion": "    return listx;\n}", "unique_id": "MBCPP_587_10", "index": 5139}
{"task_id": "MBCPP/588", "completion": "    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    return max_val - min_val;\n}", "unique_id": "MBCPP_588_5", "index": 5144}
{"task_id": "MBCPP/589", "completion": "    vector<int> result;\n    int start = ceil(sqrt(a));\n    int end = floor(sqrt(b));\n    for (int i = start; i <= end; ++i) {\n        result.push_back(i * i);\n    }\n    return result;\n}", "unique_id": "MBCPP_589_7", "index": 5156}
{"task_id": "MBCPP/591", "completion": "    if (newlist.size() > 1) {\n        swap(newlist[0], newlist[newlist.size() - 1]);\n    }\n    return newlist;\n}", "unique_id": "MBCPP_591_3", "index": 5162}
{"task_id": "MBCPP/592", "completion": "    int sum = 0;\n    for (int k = 0; k <= n; ++k) {\n        int product = 1;\n        for (int i = 0; i <= k; ++i) {\n            product *= (n - i + 1) / (i + 1);\n        }\n        sum += product;\n    }\n    return sum;\n}", "unique_id": "MBCPP_592_8", "index": 5177}
{"task_id": "MBCPP/593", "completion": "    stringstream ss(ip);\n    string segment, result;\n    vector<string> segments;\n\n    while (getline(ss, segment, '.')) {\n        int start = 0;\n        while (start < segment.size() && segment[start] == '0') {\n            start++;\n        }\n        if (start == segment.size()) {\n            segments.push_back(\"0\");\n        } else {\n            segments.push_back(segment.substr(start));\n        }\n    }\n\n    result = segments[0];\n    for (int i = 1; i < segments.size(); ++i) {\n        result += \".\" + segments[i];\n    }\n\n    return result;\n}", "unique_id": "MBCPP_593_2", "index": 5181}
{"task_id": "MBCPP/594", "completion": "    int first_even = -1;\n    int first_odd = -1;\n\n    for (int num : list1) {\n        if (num % 2 == 0 && first_even == -1) {\n            first_even = num;\n        }\n        if (num % 2 != 0 && first_odd == -1) {\n            first_odd = num;\n        }\n        if (first_even != -1 && first_odd != -1) {\n            break;\n        }\n    }\n\n    if (first_even == -1 || first_odd == -1) {\n        throw invalid_argument(\"List must contain at least one even and one odd number.\");\n    }\n\n    return abs(first_even - first_odd);\n}", "unique_id": "MBCPP_594_5", "index": 5194}
{"task_id": "MBCPP/597", "completion": "    if (m > n) {\n        return findKth(arr2, arr1, n, m, k);\n    }\n    if (m == 0) {\n        return arr2[k - 1];\n    }\n    if (k == 1) {\n        return min(arr1[0], arr2[0]);\n    }\n\n    int i = min(m, k / 2);\n    int j = min(n, k / 2);\n\n    if (arr1[i - 1] > arr2[j - 1]) {\n        vector<int> newArr2(arr2.begin() + j, arr2.end());\n        return findKth(arr1, newArr2, m, n - j, k - j);\n    } else {\n        vector<int> newArr1(arr1.begin() + i, arr1.end());\n        return findKth(newArr1, arr2, m - i, n, k - i);\n    }\n}", "unique_id": "MBCPP_597_3", "index": 5202}
{"task_id": "MBCPP/598", "completion": "    int sum = 0, temp, remainder, n = 0;\n    temp = number;\n    while (temp != 0) {\n        temp /= 10;\n        n++;\n    }\n    temp = number;\n    while (temp != 0) {\n        remainder = temp % 10;\n        sum += pow(remainder, n);\n        temp /= 10;\n    }\n    return (sum == number);\n}", "unique_id": "MBCPP_598_8", "index": 5217}
{"task_id": "MBCPP/600", "completion": "    return (n & 1) == 0;\n}", "unique_id": "MBCPP_600_5", "index": 5224}
{"task_id": "MBCPP/602", "completion": "    unordered_set<char> seen;\n    for (char c : str1) {\n        if (seen.count(c))\n            return string(1, c);\n        seen.insert(c);\n    }\n    return \"None\";\n}", "unique_id": "MBCPP_602_9", "index": 5238}
{"task_id": "MBCPP/603", "completion": "    vector<int> ludics;\n    for (int i = 1; i <= n; ++i) {\n        ludics.push_back(i);\n    }\n    int pos = 1;\n    while (pos < ludics.size()) {\n        int step = ludics[pos];\n        ludics.erase(remove_if(ludics.begin() + pos + 1, ludics.end(), [step](int x, int index = 0) mutable { return ++index % step == 0; }), ludics.end());\n        ++pos;\n    }\n    return ludics;\n}", "unique_id": "MBCPP_603_1", "index": 5240}
{"task_id": "MBCPP/604", "completion": "    istringstream iss(s);\n    vector<string> words;\n    string word;\n    while (iss >> word) {\n        words.push_back(word);\n    }\n    reverse(words.begin(), words.end());\n    ostringstream oss;\n    for (size_t i = 0; i < words.size(); ++i) {\n        if (i != 0) oss << \" \";\n        oss << words[i];\n    }\n    return oss.str();\n}", "unique_id": "MBCPP_604_7", "index": 5256}
{"task_id": "MBCPP/605", "completion": "    if (num <= 1) return false;\n    if (num <= 3) return true;\n    if (num % 2 == 0 || num % 3 == 0) return false;\n    for (int i = 5; i * i <= num; i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) return false;\n    }\n    return true;\n}", "unique_id": "MBCPP_605_6", "index": 5265}
{"task_id": "MBCPP/606", "completion": "    return degree * (M_PI / 180.0);\n}", "unique_id": "MBCPP_606_4", "index": 5273}
{"task_id": "MBCPP/608", "completion": "    vector<vector<int>> bell(n + 1, vector<int>(n + 1, 0));\n    bell[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        bell[i][0] = bell[i - 1][i - 1];\n        for (int j = 1; j <= i; j++) {\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1];\n        }\n    }\n    return bell[n][0];\n}", "unique_id": "MBCPP_608_10", "index": 5289}
{"task_id": "MBCPP/609", "completion": "    return min({a, b, n});\n}", "unique_id": "MBCPP_609_4", "index": 5293}
{"task_id": "MBCPP/610", "completion": "    if (l >= 0 && l < list1.size()) {\n        list1.erase(list1.begin() + l);\n    }\n    return list1;\n}", "unique_id": "MBCPP_610_3", "index": 5302}
{"task_id": "MBCPP/611", "completion": "    int maxVal = INT_MIN;\n    for (const auto& row : testList) {\n        if (n < row.size()) {\n            maxVal = max(maxVal, row[n]);\n        }\n    }\n    return maxVal;\n}", "unique_id": "MBCPP_611_5", "index": 5314}
{"task_id": "MBCPP/614", "completion": "    int sum = 0;\n    for (const auto& tuple : testList) {\n        for (int num : tuple) {\n            sum += num;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_614_3", "index": 5322}
{"task_id": "MBCPP/615", "completion": "    vector<double> averages;\n    int numRows = nums.size();\n    int numCols = nums[0].size();\n    \n    for (int col = 0; col < numCols; ++col) {\n        double sum = 0;\n        for (int row = 0; row < numRows; ++row) {\n            sum += nums[row][col];\n        }\n        averages.push_back(sum / numRows);\n    }\n    \n    return averages;\n}", "unique_id": "MBCPP_615_5", "index": 5334}
{"task_id": "MBCPP/616", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        result.push_back(testTup1[i] % testTup2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_616_7", "index": 5346}
{"task_id": "MBCPP/618", "completion": "    vector<double> result;\n    transform(nums1.begin(), nums1.end(), nums2.begin(), back_inserter(result), [](int a, int b) {\n        return static_cast<double>(a) / b;\n    });\n    return result;\n}", "unique_id": "MBCPP_618_5", "index": 5354}
{"task_id": "MBCPP/619", "completion": "    string letters, numbers;\n    for (char c : testStr) {\n        if (isdigit(c)) {\n            numbers += c;\n        } else {\n            letters += c;\n        }\n    }\n    return letters + numbers;\n}", "unique_id": "MBCPP_619_6", "index": 5365}
{"task_id": "MBCPP/620", "completion": "    sort(a.begin(), a.end());\n    vector<int> dp(n, 1);\n    \n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (a[i] % a[j] == 0) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    return *max_element(dp.begin(), dp.end());\n}", "unique_id": "MBCPP_620_9", "index": 5378}
{"task_id": "MBCPP/621", "completion": "    for (auto& str : testList) {\n        if (all_of(str.begin(), str.end(), ::isdigit)) {\n            int num = stoi(str);\n            num += k;\n            str = to_string(num);\n        }\n    }\n    return testList;\n}", "unique_id": "MBCPP_621_2", "index": 5381}
{"task_id": "MBCPP/622", "completion": "    int i = 0; \n    int j = 0; \n    int count; \n    int m1 = -1, m2 = -1; \n\n    for (count = 0; count <= n; count++) { \n        if (i == n) { \n            m1 = m2; \n            m2 = arr2[0];\n            break;\n        } \n        else if (j == n) { \n            m1 = m2; \n            m2 = arr1[0]; \n            break; \n        } \n\n        if (arr1[i] <= arr2[j]) { \n            m1 = m2; \n            m2 = arr1[i]; \n            i++; \n        } \n        else { \n            m1 = m2; \n            m2 = arr2[j]; \n            j++; \n        } \n    } \n\n    return (m1 + m2) / 2.0;\n}", "unique_id": "MBCPP_622_10", "index": 5399}
{"task_id": "MBCPP/623", "completion": "    vector<int> result;\n    transform(nums.begin(), nums.end(), back_inserter(result), [n](int num) {\n        return pow(num, n);\n    });\n    return result;\n}", "unique_id": "MBCPP_623_6", "index": 5405}
{"task_id": "MBCPP/624", "completion": "    transform(str.begin(), str.end(), str.begin(), ::toupper);\n    return str;\n}", "unique_id": "MBCPP_624_3", "index": 5412}
{"task_id": "MBCPP/625", "completion": "    if (newlist.size() > 1) {\n        swap(newlist[0], newlist[newlist.size() - 1]);\n    }\n    return newlist;\n}", "unique_id": "MBCPP_625_8", "index": 5427}
{"task_id": "MBCPP/626", "completion": "    if (r <= 0) return r;\n    return r * r;\n}", "unique_id": "MBCPP_626_6", "index": 5435}
{"task_id": "MBCPP/627", "completion": "    if (start > end)\n        return start;\n    int mid = (start + end) / 2;\n    if (array[mid] != mid)\n        return findFirstMissing(array, start, mid - 1);\n    return findFirstMissing(array, mid + 1, end);\n}", "unique_id": "MBCPP_627_6", "index": 5445}
{"task_id": "MBCPP/628", "completion": "    string result;\n    for (char c : str) {\n        if (c == ' ') {\n            result += \"%20\";\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_628_8", "index": 5457}
{"task_id": "MBCPP/629", "completion": "    vector<int> evens;\n    for (int num : list) {\n        if (num % 2 == 0) {\n            evens.push_back(num);\n        }\n    }\n    return evens;\n}", "unique_id": "MBCPP_629_4", "index": 5463}
{"task_id": "MBCPP/630", "completion": "    vector<vector<int>> result;\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            result.push_back({testTup[0] + i, testTup[1] + j});\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_630_5", "index": 5474}
{"task_id": "MBCPP/631", "completion": "    text = regex_replace(text, regex(\" \"), \"_\");\n    text = regex_replace(text, regex(\"_\"), \" \");\n    return text;\n}", "unique_id": "MBCPP_631_1", "index": 5480}
{"task_id": "MBCPP/632", "completion": "    int count = 0;\n    for (int i = 0; i < numList.size(); i++) {\n        if (numList[i] != 0) {\n            numList[count++] = numList[i];\n        }\n    }\n    while (count < numList.size()) {\n        numList[count++] = 0;\n    }\n    return numList;\n}", "unique_id": "MBCPP_632_1", "index": 5490}
{"task_id": "MBCPP/633", "completion": "    int sum = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = i + 1; j < n; ++j) {\n            sum += arr[i] ^ arr[j];\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_633_5", "index": 5504}
{"task_id": "MBCPP/634", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        int evenNumber = 2 * i;\n        sum += pow(evenNumber, 4);\n    }\n    return sum;\n}", "unique_id": "MBCPP_634_10", "index": 5519}
{"task_id": "MBCPP/635", "completion": "    priority_queue<int, vector<int>, greater<int>> minHeap(iterable.begin(), iterable.end());\n    vector<int> sorted;\n    while (!minHeap.empty()) {\n        sorted.push_back(minHeap.top());\n        minHeap.pop();\n    }\n    return sorted;\n}", "unique_id": "MBCPP_635_8", "index": 5527}
{"task_id": "MBCPP/636", "completion": "    if (b == 0 && a == c)\n        return \"Yes\";\n    else if (a + c == b)\n        return \"Yes\";\n    else\n        return \"No\";\n}", "unique_id": "MBCPP_636_3", "index": 5532}
{"task_id": "MBCPP/637", "completion": "    return actualCost == saleAmount;\n}", "unique_id": "MBCPP_637_5", "index": 5544}
{"task_id": "MBCPP/638", "completion": "    return (int)(33 + (10 * sqrt(v) + 10.45 - v) * (33 - t) / 22);\n}", "unique_id": "MBCPP_638_3", "index": 5552}
{"task_id": "MBCPP/639", "completion": "    int totalLength = 0;\n    for (const auto& name : sampleNames) {\n        if (!name.empty() && isupper(name[0])) {\n            totalLength += name.length();\n        }\n    }\n    return totalLength;\n}", "unique_id": "MBCPP_639_9", "index": 5568}
{"task_id": "MBCPP/640", "completion": "    string result = items[0];\n    size_t start = result.find('(');\n    size_t end = result.find(')');\n    if (start != string::npos && end != string::npos && start < end) {\n        result.erase(start, end - start + 1);\n    }\n    return result;\n}", "unique_id": "MBCPP_640_5", "index": 5574}
{"task_id": "MBCPP/641", "completion": "    return (n * (7 * n - 5)) / 2;\n}", "unique_id": "MBCPP_641_4", "index": 5583}
{"task_id": "MBCPP/643", "completion": "    regex pattern(R\"(\\b\\w+z\\w+\\b)\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_643_9", "index": 5598}
{"task_id": "MBCPP/644", "completion": "    reverse(input.begin(), input.begin() + k);\n    return input;\n}", "unique_id": "MBCPP_644_3", "index": 5602}
{"task_id": "MBCPP/645", "completion": "    int product = 1;\n    for (const auto& tuple : testList) {\n        product *= tuple[k];\n    }\n    return product;\n}", "unique_id": "MBCPP_645_4", "index": 5613}
{"task_id": "MBCPP/646", "completion": "    return (n / k) * (n / k) * (n / k);\n}", "unique_id": "MBCPP_646_8", "index": 5627}
{"task_id": "MBCPP/647", "completion": "    vector<string> result;\n    string current;\n    for (char ch : text) {\n        if (isupper(ch) && !current.empty()) {\n            result.push_back(current);\n            current.clear();\n        }\n        current += ch;\n    }\n    if (!current.empty()) {\n        result.push_back(current);\n    }\n    return result;\n}", "unique_id": "MBCPP_647_7", "index": 5636}
{"task_id": "MBCPP/648", "completion": "    for (size_t i = 0; i < lst.size() - 1; i += 2) {\n        swap(lst[i], lst[i + 1]);\n    }\n    return lst;\n}", "unique_id": "MBCPP_648_1", "index": 5640}
{"task_id": "MBCPP/649", "completion": "    int sum = 0;\n    for (int i = m; i <= n; ++i) {\n        sum += nums[i];\n    }\n    return sum;\n}", "unique_id": "MBCPP_649_8", "index": 5657}
{"task_id": "MBCPP/650", "completion": "    if (n != m) {\n        return false;\n    }\n    sort(arr1.begin(), arr1.end());\n    sort(arr2.begin(), arr2.end());\n    for (int i = 0; i < n; i++) {\n        if (arr1[i] != arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_650_9", "index": 5668}
{"task_id": "MBCPP/651", "completion": "    unordered_set<int> set(testTup1.begin(), testTup1.end());\n    for (int num : testTup2) {\n        if (set.find(num) == set.end()) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_651_6", "index": 5675}
{"task_id": "MBCPP/652", "completion": "    vector<vector<int>> result;\n    for (int i = 0; i < testList[0].size(); ++i) {\n        vector<int> temp;\n        for (int j = 0; j < testList.size(); ++j) {\n            temp.push_back(testList[j][i][0]);\n            temp.push_back(testList[j][i][1]);\n        }\n        result.push_back(temp);\n    }\n    string res = \"[\";\n    for (int i = 0; i < result[0].size(); i += 2) {\n        res += \"(\";\n        for (int j = 0; j < result.size(); ++j) {\n            res += to_string(result[j][i]) + \", \" + to_string(result[j][i + 1]);\n            if (j < result.size() - 1) res += \", \";\n        }\n        res += \"), \";\n    }\n    if (res.size() > 1) res.pop_back(), res.pop_back();\n    res += \"]\";\n    return res;\n}", "unique_id": "MBCPP_652_2", "index": 5681}
{"task_id": "MBCPP/654", "completion": "    return 2 * (l + b);\n}", "unique_id": "MBCPP_654_3", "index": 5692}
{"task_id": "MBCPP/655", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum += pow(i, 5);\n    }\n    return sum;\n}", "unique_id": "MBCPP_655_5", "index": 5704}
{"task_id": "MBCPP/656", "completion": "    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    int minSum = 0;\n    for(int i = 0; i < n; i++) {\n        minSum += abs(a[i] - b[i]);\n    }\n    return minSum;\n}", "unique_id": "MBCPP_656_4", "index": 5713}
{"task_id": "MBCPP/657", "completion": "    if (n == 0 || n == 1) \n        return 1;\n    double logSum = 0;\n    for (int i = 2; i <= n; i++) {\n        logSum += log10(i);\n    }\n    double fractionalPart = logSum - floor(logSum);\n    double firstDigit = pow(10, fractionalPart);\n    return (int)firstDigit;\n}", "unique_id": "MBCPP_657_2", "index": 5721}
{"task_id": "MBCPP/658", "completion": "    unordered_map<int, int> freq;\n    for (int num : list1) {\n        freq[num]++;\n    }\n\n    int max_count = 0;\n    int max_item = list1[0];\n\n    for (const auto& [item, count] : freq) {\n        if (count > max_count) {\n            max_count = count;\n            max_item = item;\n        }\n    }\n\n    return max_item;\n}", "unique_id": "MBCPP_658_2", "index": 5731}
{"task_id": "MBCPP/659", "completion": "    unordered_map<int, int> freq;\n    vector<int> result;\n\n    for (int num : x) {\n        freq[num]++;\n    }\n\n    for (auto &p : freq) {\n        if (p.second > 1) {\n            result.push_back(p.first);\n        }\n    }\n\n    return result;\n}", "unique_id": "MBCPP_659_2", "index": 5741}
{"task_id": "MBCPP/660", "completion": "    if (r1 < l2 || r2 < l1) {\n        // If the ranges do not overlap, just choose the boundary points\n        return {l1, r2};\n    } else {\n        // If the ranges overlap, choose the extreme points\n        return {min(l1, l2), max(r1, r2)};\n    }\n}", "unique_id": "MBCPP_660_8", "index": 5757}
{"task_id": "MBCPP/661", "completion": "    if (n == 0) return 0;\n    if (n == 1) return arr[0];\n    if (n == 2) return arr[0] + arr[1];\n\n    vector<int> dp(n);\n    dp[0] = arr[0];\n    dp[1] = arr[0] + arr[1];\n    dp[2] = max({arr[0] + arr[1], arr[1] + arr[2], arr[0] + arr[2]});\n\n    for (int i = 3; i < n; i++) {\n        dp[i] = max({dp[i-1], dp[i-2] + arr[i], dp[i-3] + arr[i] + arr[i-1]});\n    }\n\n    return dp[n-1];\n}", "unique_id": "MBCPP_661_7", "index": 5766}
{"task_id": "MBCPP/662", "completion": "    for (auto& pair : dict1) {\n        sort(pair.second.begin(), pair.second.end());\n    }\n    return dict1;\n}", "unique_id": "MBCPP_662_8", "index": 5777}
{"task_id": "MBCPP/663", "completion": "    return n - (n - y) % x;\n}", "unique_id": "MBCPP_663_6", "index": 5785}
{"task_id": "MBCPP/664", "completion": "    int sum = 0;\n    int count = 0;\n    for (int i = 2; i <= n; i += 2) {\n        sum += i;\n        count++;\n    }\n    return sum / count;\n}", "unique_id": "MBCPP_664_4", "index": 5793}
{"task_id": "MBCPP/665", "completion": "    if (!numList.empty()) {\n        int firstElement = numList.front();\n        numList.erase(numList.begin());\n        numList.push_back(firstElement);\n    }\n    return numList;\n}", "unique_id": "MBCPP_665_6", "index": 5805}
{"task_id": "MBCPP/666", "completion": "    return count(str.begin(), str.end(), chr[0]);\n}", "unique_id": "MBCPP_666_1", "index": 5810}
{"task_id": "MBCPP/667", "completion": "    unordered_set<char> vowelSet(vowels.begin(), vowels.end());\n    int count = 0;\n    for (char c : str) {\n        if (vowelSet.find(c) != vowelSet.end()) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_667_7", "index": 5826}
{"task_id": "MBCPP/668", "completion": "    string result;\n    bool found = false;\n    for (char c : str) {\n        if (c == chr[0]) {\n            if (!found) {\n                result += c;\n                found = true;\n            }\n        } else {\n            result += c;\n            found = false;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_668_8", "index": 5837}
{"task_id": "MBCPP/669", "completion": "    regex ip_pattern(\"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\");\n    if (regex_match(ip, ip_pattern)) {\n        return \"Valid IP address\";\n    } else {\n        return \"Invalid IP address\";\n    }\n}", "unique_id": "MBCPP_669_9", "index": 5848}
{"task_id": "MBCPP/670", "completion": "    int n = nums.size();\n    if (n <= 1) return true;\n    for (int i = 1; i < n; ++i) {\n        if (nums[i] > nums[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_670_2", "index": 5851}
{"task_id": "MBCPP/671", "completion": "    if (n == 0)\n        return 1;\n    int m = 1;\n    while (n & m)\n        m = m << 1;\n    return n | m;\n}", "unique_id": "MBCPP_671_1", "index": 5860}
{"task_id": "MBCPP/672", "completion": "    return max(num1, max(num2, num3));\n}", "unique_id": "MBCPP_672_8", "index": 5877}
{"task_id": "MBCPP/673", "completion": "    int result = 0;\n    for (int num : list) {\n        result = result * 10 + num;\n    }\n    return result;\n}", "unique_id": "MBCPP_673_9", "index": 5888}
{"task_id": "MBCPP/674", "completion": "    unordered_set<string> seen;\n    stringstream ss(str);\n    string word;\n    string result;\n    while (ss >> word) {\n        if (seen.find(word) == seen.end()) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n            seen.insert(word);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_674_10", "index": 5899}
{"task_id": "MBCPP/675", "completion": "    int sum = x + y;\n    if (sum >= m && sum <= n) {\n        return 20;\n    } else {\n        return sum;\n    }\n}", "unique_id": "MBCPP_675_8", "index": 5907}
{"task_id": "MBCPP/676", "completion": "    return regex_replace(text1, regex(\"[^a-zA-Z0-9]\"), \"\");\n}", "unique_id": "MBCPP_676_5", "index": 5914}
{"task_id": "MBCPP/677", "completion": "    return (a + b + c == 180 && a > 0 && b > 0 && c > 0);\n}", "unique_id": "MBCPP_677_1", "index": 5920}
{"task_id": "MBCPP/678", "completion": "    str1.erase(remove(str1.begin(), str1.end(), ' '), str1.end());\n    return str1;\n}", "unique_id": "MBCPP_678_6", "index": 5935}
{"task_id": "MBCPP/679", "completion": "    auto it = ditionary.begin();\n    advance(it, key);\n    return it->first;\n}", "unique_id": "MBCPP_679_5", "index": 5944}
{"task_id": "MBCPP/680", "completion": "    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] <= nums[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_680_9", "index": 5958}
{"task_id": "MBCPP/681", "completion": "    if (n <= 1) return n;\n    if (n % 2 == 0) return 2;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return i;\n    }\n    return n;\n}", "unique_id": "MBCPP_681_9", "index": 5968}
{"task_id": "MBCPP/682", "completion": "    vector<int> result;\n    transform(nums1.begin(), nums1.end(), nums2.begin(), back_inserter(result), [](int a, int b) { return a * b; });\n    return result;\n}", "unique_id": "MBCPP_682_6", "index": 5975}
{"task_id": "MBCPP/683", "completion": "    for (int i = 0; i * i <= n; ++i) {\n        int j = sqrt(n - i * i);\n        if (i * i + j * j == n) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_683_2", "index": 5981}
{"task_id": "MBCPP/684", "completion": "    int n = str.length();\n    int count_in_str = count(str.begin(), str.end(), x[0]);\n\n    long long repetitions = 1000000000 / n;\n    long long total_count = repetitions * count_in_str;\n\n    long long remaining = 1000000000 % n;\n    for (int i = 0; i < remaining; i++) {\n        if (str[i] == x[0]) {\n            total_count++;\n        }\n    }\n\n    return total_count;\n}", "unique_id": "MBCPP_684_6", "index": 5995}
{"task_id": "MBCPP/685", "completion": "    if (n < 2) return 0;\n    vector<bool> isPrime(n + 1, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int sum = 0;\n    for (int i = 2; i <= n; ++i) {\n        if (isPrime[i]) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_685_2", "index": 6001}
{"task_id": "MBCPP/686", "completion": "    unordered_map<int, int> freqMap;\n    for (int num : testTup) {\n        freqMap[num]++;\n    }\n\n    string result = \"{\";\n    for (auto it = freqMap.begin(); it != freqMap.end(); ++it) {\n        if (it != freqMap.begin()) {\n            result += \", \";\n        }\n        result += to_string(it->first) + \": \" + to_string(it->second);\n    }\n    result += \"}\";\n\n    return result;\n}", "unique_id": "MBCPP_686_8", "index": 6017}
{"task_id": "MBCPP/687", "completion": "    if (b == 0)\n        return a;\n    return recurGcd(b, a % b);\n}", "unique_id": "MBCPP_687_2", "index": 6021}
{"task_id": "MBCPP/688", "completion": "    return sqrt(a * a + b * b);\n}", "unique_id": "MBCPP_688_5", "index": 6034}
{"task_id": "MBCPP/689", "completion": "    if (n == 1) return 0;\n    if (arr[0] == 0) return -1;\n\n    int jumps = 1;\n    int maxReach = arr[0];\n    int steps = arr[0];\n\n    for (int i = 1; i < n; i++) {\n        if (i == n - 1) return jumps;\n\n        maxReach = max(maxReach, i + arr[i]);\n        steps--;\n\n        if (steps == 0) {\n            jumps++;\n            if (i >= maxReach) return -1;\n            steps = maxReach - i;\n        }\n    }\n\n    return -1;\n}", "unique_id": "MBCPP_689_9", "index": 6048}
{"task_id": "MBCPP/690", "completion": "    vector<int> result;\n    for (size_t i = 0; i < nums.size() - 1; ++i) {\n        result.push_back(nums[i] * nums[i + 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_690_9", "index": 6058}
{"task_id": "MBCPP/691", "completion": "    unordered_map<int, vector<int>> result;\n    for (const auto& elem : testList) {\n        int first = elem[0];\n        int second = elem[1];\n        result[second].push_back(first);\n    }\n    return result;\n}", "unique_id": "MBCPP_691_1", "index": 6060}
{"task_id": "MBCPP/692", "completion": "    if (n == 0 || n == 1)\n        return 1;\n    \n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result *= i;\n        \n        // Keep only the last two digits\n        result %= 100;\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_692_2", "index": 6071}
{"task_id": "MBCPP/693", "completion": "    regex multipleSpaces(\" +\");\n    return regex_replace(text1, multipleSpaces, \" \");\n}", "unique_id": "MBCPP_693_2", "index": 6081}
{"task_id": "MBCPP/694", "completion": "    set<int> uniqueValues;\n    for (const auto& pair : testDict) {\n        for (int value : pair.second) {\n            uniqueValues.insert(value);\n        }\n    }\n    return vector<int>(uniqueValues.begin(), uniqueValues.end());\n}", "unique_id": "MBCPP_694_6", "index": 6095}
{"task_id": "MBCPP/695", "completion": "    for (size_t i = 0; i < testTup1.size(); ++i) {\n        if (testTup2[i] <= testTup1[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_695_3", "index": 6102}
{"task_id": "MBCPP/697", "completion": "    return count_if(arrayNums.begin(), arrayNums.end(), [](int n) { return n % 2 == 0; });\n}", "unique_id": "MBCPP_697_10", "index": 6119}
{"task_id": "MBCPP/701", "completion": "    int total_sum = accumulate(arr.begin(), arr.end(), 0);\n    int left_sum = 0;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        total_sum -= arr[i];\n        if (left_sum == total_sum) {\n            return i;\n        }\n        left_sum += arr[i];\n    }\n    \n    return -1;\n}", "unique_id": "MBCPP_701_7", "index": 6126}
{"task_id": "MBCPP/702", "completion": "    sort(arr.begin(), arr.end());\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int len = 1; len < n; len++) {\n        for (int i = 0, j = len; j < n; i++, j++) {\n            if (arr[j] - arr[i] <= k) {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}", "unique_id": "MBCPP_702_5", "index": 6134}
{"task_id": "MBCPP/703", "completion": "    return d.find(x) != d.end();\n}", "unique_id": "MBCPP_703_3", "index": 6142}
{"task_id": "MBCPP/704", "completion": "    double sum = 0.0;\n    for (int i = 1; i < n; ++i) {\n        sum += 1.0 / i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_704_9", "index": 6158}
{"task_id": "MBCPP/706", "completion": "    unordered_set<int> elements(arr1.begin(), arr1.end());\n    for (int i = 0; i < n; i++) {\n        if (elements.find(arr2[i]) == elements.end()) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_706_2", "index": 6161}
{"task_id": "MBCPP/707", "completion": "    int count = 0;\n    for (int i = 1; i <= n; i++) {\n        count += __builtin_popcount(i);\n    }\n    return count;\n}", "unique_id": "MBCPP_707_1", "index": 6170}
{"task_id": "MBCPP/708", "completion": "    vector<string> result;\n    stringstream ss(str);\n    string word;\n    while (ss >> word) {\n        result.push_back(word);\n    }\n    return result;\n}", "unique_id": "MBCPP_708_6", "index": 6185}
{"task_id": "MBCPP/709", "completion": "    map<int, set<int>> valueToKeys;\n    for (const auto& pair : testList) {\n        valueToKeys[pair[1]].insert(pair[0]);\n    }\n    \n    string result = \"{\";\n    for (auto it = valueToKeys.begin(); it != valueToKeys.end(); ++it) {\n        if (it != valueToKeys.begin()) {\n            result += \", \";\n        }\n        result += to_string(it->first) + \": \" + to_string(it->second.size());\n    }\n    result += \"}\";\n    \n    return result;\n}", "unique_id": "MBCPP_709_5", "index": 6194}
{"task_id": "MBCPP/710", "completion": "    return {testTup.front(), testTup.back()};\n}", "unique_id": "MBCPP_710_8", "index": 6207}
{"task_id": "MBCPP/711", "completion": "    int oddProduct = 1, evenProduct = 1;\n    bool isOdd = true;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        n /= 10;\n        \n        if (isOdd) {\n            oddProduct *= digit;\n        } else {\n            evenProduct *= digit;\n        }\n        \n        isOdd = !isOdd;\n    }\n    \n    return oddProduct == evenProduct;\n}", "unique_id": "MBCPP_711_7", "index": 6216}
{"task_id": "MBCPP/713", "completion": "    for(bool val : testTup) {\n        if (!val) return false;\n    }\n    return true;\n}", "unique_id": "MBCPP_713_4", "index": 6223}
{"task_id": "MBCPP/714", "completion": "    set<int> factors;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.insert(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.insert(n);\n    }\n    return factors.size();\n}", "unique_id": "MBCPP_714_5", "index": 6234}
{"task_id": "MBCPP/715", "completion": "    vector<int> result;\n    stringstream ss(testStr);\n    string temp;\n    while (getline(ss, temp, ',')) {\n        result.push_back(stoi(temp));\n    }\n    return result;\n}", "unique_id": "MBCPP_715_10", "index": 6249}
{"task_id": "MBCPP/716", "completion": "    return 4 * a;\n}", "unique_id": "MBCPP_716_6", "index": 6255}
{"task_id": "MBCPP/717", "completion": "    int n = data.size();\n    if (n == 0) return 0.0;\n    \n    double mean = accumulate(data.begin(), data.end(), 0.0) / n;\n    double variance = 0.0;\n    \n    for (int num : data) {\n        variance += (num - mean) * (num - mean);\n    }\n    \n    variance /= n;\n    return sqrt(variance);\n}", "unique_id": "MBCPP_717_5", "index": 6264}
{"task_id": "MBCPP/719", "completion": "    regex pattern(\"ab*\");\n    if (regex_search(text, pattern))\n        return \"Found a match!\";\n    else\n        return \"Not matched!\";\n}", "unique_id": "MBCPP_719_9", "index": 6278}
{"task_id": "MBCPP/721", "completion": "    vector<vector<double>> dp(n, vector<double>(n, 0));\n    dp[0][0] = cost[0][0];\n\n    for(int i = 1; i < n; ++i) {\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n\n    for(int i = 1; i < n; ++i) {\n        for(int j = 1; j < n; ++j) {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n\n    return dp[n-1][n-1] / (2*n - 1);\n}", "unique_id": "MBCPP_721_1", "index": 6280}
{"task_id": "MBCPP/723", "completion": "    int count = 0;\n    int size = min(nums1.size(), nums2.size());\n    for (int i = 0; i < size; ++i) {\n        if (nums1[i] == nums2[i]) {\n            ++count;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_723_1", "index": 6290}
{"task_id": "MBCPP/724", "completion": "    string result = to_string(static_cast<unsigned long long>(pow(base, power)));\n    int sum = 0;\n    for (char c : result) {\n        sum += c - '0';\n    }\n    return sum;\n}", "unique_id": "MBCPP_724_6", "index": 6305}
{"task_id": "MBCPP/725", "completion": "    vector<string> result;\n    regex re(\"\\\"([^\\\"]*)\\\"\");\n    smatch match;\n    while (regex_search(text1, match, re)) {\n        result.push_back(match[1].str());\n        text1 = match.suffix().str();\n    }\n    return result;\n}", "unique_id": "MBCPP_725_3", "index": 6312}
{"task_id": "MBCPP/726", "completion": "    vector<int> result;\n    for (size_t i = 0; i < testTup.size() - 1; ++i) {\n        result.push_back(testTup[i] * testTup[i + 1]);\n    }\n    return result;\n}", "unique_id": "MBCPP_726_5", "index": 6324}
{"task_id": "MBCPP/727", "completion": "    return regex_replace(s, regex(\"[^a-zA-Z0-9]\"), \"\");\n}", "unique_id": "MBCPP_727_5", "index": 6334}
{"task_id": "MBCPP/728", "completion": "    vector<int> result;\n    for (size_t i = 0; i < lst1.size(); ++i) {\n        result.push_back(lst1[i] + lst2[i]);\n    }\n    return result;\n}", "unique_id": "MBCPP_728_3", "index": 6342}
{"task_id": "MBCPP/729", "completion": "    vector<int> result;\n    transform(nums1.begin(), nums1.end(), nums2.begin(), back_inserter(result), [](int a, int b) {\n        return a + b;\n    });\n    return result;\n}", "unique_id": "MBCPP_729_2", "index": 6351}
{"task_id": "MBCPP/731", "completion": "    double l = sqrt(r * r + h * h);\n    return M_PI * r * l;\n}", "unique_id": "MBCPP_731_10", "index": 6369}
{"task_id": "MBCPP/732", "completion": "    for (char& ch : text) {\n        if (ch == ' ' || ch == ',' || ch == '.') {\n            ch = ':';\n        }\n    }\n    return text;\n}", "unique_id": "MBCPP_732_1", "index": 6370}
{"task_id": "MBCPP/733", "completion": "    int left = 0, right = a.size() - 1;\n    int result = -1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (a[mid] == x) {\n            result = mid;\n            right = mid - 1;\n        } else if (a[mid] < x) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_733_4", "index": 6383}
{"task_id": "MBCPP/734", "completion": "    int result = 0;\n    for (int i = 0; i < n; i++) {\n        int product = 1;\n        for (int j = i; j < n; j++) {\n            product *= arr[j];\n            result += product;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_734_3", "index": 6392}
{"task_id": "MBCPP/735", "completion": "    if (n <= 1) return n;\n    int num_bits = sizeof(n) * 8;\n    int mask = ((1 << (num_bits - 2)) - 1) ^ 1;\n    return n ^ mask;\n}", "unique_id": "MBCPP_735_6", "index": 6405}
{"task_id": "MBCPP/736", "completion": "    return lower_bound(a.begin(), a.end(), x) - a.begin();\n}", "unique_id": "MBCPP_736_2", "index": 6411}
{"task_id": "MBCPP/737", "completion": "    regex vowel_regex(\"^[aeiouAEIOU].*\");\n    if (regex_match(str, vowel_regex)) {\n        return \"Valid\";\n    } else {\n        return \"Invalid\";\n    }\n}", "unique_id": "MBCPP_737_5", "index": 6424}
{"task_id": "MBCPP/738", "completion": "    if (n == 0)\n        return 1;\n    return 1 / pow(2, n - 1) + geometricSum(n - 1);\n}", "unique_id": "MBCPP_738_1", "index": 6430}
{"task_id": "MBCPP/739", "completion": "    int index = 1;\n    while (true) {\n        int triangularNumber = index * (index + 1) / 2;\n        if (to_string(triangularNumber).length() == n) {\n            return index;\n        }\n        index++;\n    }\n}", "unique_id": "MBCPP_739_2", "index": 6441}
{"task_id": "MBCPP/740", "completion": "    unordered_map<int, int> dict;\n    for (size_t i = 0; i + 1 < testTup.size(); i += 2) {\n        dict[testTup[i]] = testTup[i + 1];\n    }\n    return dict;\n}", "unique_id": "MBCPP_740_1", "index": 6450}
{"task_id": "MBCPP/741", "completion": "    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_741_1", "index": 6460}
{"task_id": "MBCPP/742", "completion": "    return sqrt(3) * side * side;\n}", "unique_id": "MBCPP_742_1", "index": 6470}
{"task_id": "MBCPP/743", "completion": "    int len1 = list1.size();\n    if (len1 == 0 || m == 0) return list1;\n    \n    m = m % len1; // In case the number of rotations is greater than the size of the list\n\n    vector<int> rotated_list;\n\n    for (int i = 0; i < n; i++) {\n        // Calculate the starting point for each rotation\n        int start = (len1 - m + i) % len1;\n        for (int j = 0; j < len1; j++) {\n            rotated_list.push_back(list1[(start + j) % len1]);\n        }\n    }\n\n    return rotated_list;\n}", "unique_id": "MBCPP_743_8", "index": 6487}
{"task_id": "MBCPP/744", "completion": "    return find(testTup.begin(), testTup.end(), -1) == testTup.end();\n}", "unique_id": "MBCPP_744_10", "index": 6499}
{"task_id": "MBCPP/745", "completion": "    vector<int> result;\n    \n    for (int i = startnum; i <= endnum; ++i) {\n        int num = i;\n        bool divisible = true;\n        \n        while (num > 0) {\n            int digit = num % 10;\n            if (digit == 0 || i % digit != 0) {\n                divisible = false;\n                break;\n            }\n            num /= 10;\n        }\n        \n        if (divisible) {\n            result.push_back(i);\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_745_3", "index": 6502}
{"task_id": "MBCPP/747", "completion": "    vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(o + 1, 0)));\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            for (int k = 1; k <= o; k++) {\n                if (x[i - 1] == y[j - 1] && y[j - 1] == z[k - 1]) {\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1;\n                } else {\n                    dp[i][j][k] = max({dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1]});\n                }\n            }\n        }\n    }\n\n    return dp[m][n][o];\n}", "unique_id": "MBCPP_747_6", "index": 6515}
{"task_id": "MBCPP/748", "completion": "    return regex_replace(str1, regex(\"([A-Z])\"), \" $1\").substr(1);\n}", "unique_id": "MBCPP_748_2", "index": 6521}
{"task_id": "MBCPP/749", "completion": "    vector<int> nums;\n    for (const auto& str : numsStr) {\n        nums.push_back(stoi(str));\n    }\n    sort(nums.begin(), nums.end());\n    return nums;\n}", "unique_id": "MBCPP_749_1", "index": 6530}
{"task_id": "MBCPP/750", "completion": "    testList.insert(testList.end(), testTup.begin(), testTup.end());\n    return testList;\n}", "unique_id": "MBCPP_750_7", "index": 6546}
{"task_id": "MBCPP/751", "completion": "    int n = arr.size();\n    for (int i = 0; i <= (n - 2) / 2; i++) {\n        if (arr[i] > arr[2 * i + 1] || (2 * i + 2 < n && arr[i] > arr[2 * i + 2])) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_751_10", "index": 6559}
{"task_id": "MBCPP/752", "completion": "    if (n == 0)\n        return 0;\n    else if (n == 1)\n        return 1;\n    else\n        return jacobsthalNum(n - 1) + 2 * jacobsthalNum(n - 2);\n}", "unique_id": "MBCPP_752_3", "index": 6562}
{"task_id": "MBCPP/754", "completion": "    vector<int> result;\n    set<int> s1(l1.begin(), l1.end());\n    set<int> s2(l2.begin(), l2.end());\n    set<int> s3(l3.begin(), l3.end());\n    \n    for (int num : s1) {\n        if (s2.count(num) && s3.count(num)) {\n            result.push_back(num);\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_754_3", "index": 6572}
{"task_id": "MBCPP/756", "completion": "    regex pattern(\"a(b?)\");\n    if (regex_search(text, pattern))\n        return \"Found a match!\";\n    else\n        return \"Not matched!\";\n}", "unique_id": "MBCPP_756_7", "index": 6586}
{"task_id": "MBCPP/757", "completion": "    int count = 0;\n    unordered_set<string> seen;\n    for (const string& s : testList) {\n        string reversed_s = s;\n        reverse(reversed_s.begin(), reversed_s.end());\n        if (seen.count(reversed_s)) {\n            count++;\n        }\n        seen.insert(s);\n    }\n    return to_string(count);\n}", "unique_id": "MBCPP_757_5", "index": 6594}
{"task_id": "MBCPP/759", "completion": "    regex decimalPattern(\"^[0-9]+\\\\.[0-9]{2}$\");\n    return regex_match(num, decimalPattern);\n}", "unique_id": "MBCPP_759_2", "index": 6601}
{"task_id": "MBCPP/760", "completion": "    for (int i = 1; i < n; i++) {\n        if (arr[i] != arr[0]) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}", "unique_id": "MBCPP_760_2", "index": 6611}
{"task_id": "MBCPP/762", "completion": "    return (monthnum3 == 4 || monthnum3 == 6 || monthnum3 == 9 || monthnum3 == 11);\n}", "unique_id": "MBCPP_762_1", "index": 6620}
{"task_id": "MBCPP/763", "completion": "    sort(arr.begin(), arr.end());\n    int minDiff = INT_MAX;\n    for (int i = 1; i < n; i++) {\n        minDiff = min(minDiff, arr[i] - arr[i - 1]);\n    }\n    return minDiff;\n}", "unique_id": "MBCPP_763_5", "index": 6634}
{"task_id": "MBCPP/764", "completion": "    int count = 0;\n    for (char c : str) {\n        if (isdigit(c)) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_764_8", "index": 6647}
{"task_id": "MBCPP/765", "completion": "    int count = 0;\n    for (int i = 1; ; ++i) {\n        if (__builtin_popcount(i + 1) != 1) {  // Check if i+1 is not a power of 2\n            ++count;\n            if (count == n)\n                return i;\n        }\n    }\n}", "unique_id": "MBCPP_765_3", "index": 6652}
{"task_id": "MBCPP/766", "completion": "    vector<vector<int>> result;\n    for (int i = 0; i < l1.size() - 1; ++i) {\n        result.push_back({l1[i], l1[i + 1]});\n    }\n    return result;\n}", "unique_id": "MBCPP_766_3", "index": 6662}
{"task_id": "MBCPP/767", "completion": "    unordered_map<int, int> freq;\n    int count = 0;\n\n    for (int i = 0; i < n; i++) {\n        int complement = sum - arr[i];\n        if (freq.find(complement) != freq.end()) {\n            count += freq[complement];\n        }\n        freq[arr[i]]++;\n    }\n\n    return count;\n}", "unique_id": "MBCPP_767_8", "index": 6677}
{"task_id": "MBCPP/768", "completion": "    int count = 0;\n    while (x) {\n        count += x & 1;\n        x >>= 1;\n    }\n    return (count % 2) != 0;\n}", "unique_id": "MBCPP_768_8", "index": 6687}
{"task_id": "MBCPP/769", "completion": "    unordered_set<int> set1(li1.begin(), li1.end());\n    unordered_set<int> set2(li2.begin(), li2.end());\n    vector<int> result;\n\n    for (int num : li1) {\n        if (set2.find(num) == set2.end()) {\n            result.push_back(num);\n        }\n    }\n\n    for (int num : li2) {\n        if (set1.find(num) == set1.end()) {\n            result.push_back(num);\n        }\n    }\n\n    return result;\n}", "unique_id": "MBCPP_769_5", "index": 6694}
{"task_id": "MBCPP/770", "completion": "    int sum = 0;\n    for (int i = 1, count = 0; count < n; i += 2, ++count) {\n        sum += pow(i, 4);\n    }\n    return sum;\n}", "unique_id": "MBCPP_770_6", "index": 6705}
{"task_id": "MBCPP/771", "completion": "    stack<char> s;\n    for (char c : exp) {\n        if (c == '(' || c == '{' || c == '[') {\n            s.push(c);\n        } else {\n            if (s.empty()) return false;\n            char top = s.top();\n            s.pop();\n            if ((c == ')' && top != '(') ||\n                (c == '}' && top != '{') ||\n                (c == ']' && top != '[')) {\n                return false;\n            }\n        }\n    }\n    return s.empty();\n}", "unique_id": "MBCPP_771_9", "index": 6718}
{"task_id": "MBCPP/772", "completion": "    istringstream stream(testStr);\n    string word;\n    string result;\n    while (stream >> word) {\n        if (word.length() != k) {\n            if (!result.empty()) {\n                result += \" \";\n            }\n            result += word;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_772_4", "index": 6723}
{"task_id": "MBCPP/774", "completion": "    const regex pattern(R\"((^[\\w\\.-]+)@([\\w\\.-]+)\\.([a-z\\.]{2,6})$)\");\n    if (regex_match(email, pattern)) {\n        return \"Valid Email\";\n    } else {\n        return \"Invalid Email\";\n    }\n}", "unique_id": "MBCPP_774_7", "index": 6736}
{"task_id": "MBCPP/775", "completion": "    for (int i = 1; i < nums.size(); i += 2) {\n        if (nums[i] % 2 == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_775_8", "index": 6747}
{"task_id": "MBCPP/776", "completion": "    int count = 0;\n    auto isVowel = [](char c) {\n        c = tolower(c);\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    };\n    \n    for (int i = 1; i < testStr.size() - 1; ++i) {\n        if (isVowel(testStr[i - 1]) || isVowel(testStr[i + 1])) {\n            ++count;\n        }\n    }\n    \n    return count;\n}", "unique_id": "MBCPP_776_1", "index": 6750}
{"task_id": "MBCPP/777", "completion": "    unordered_map<int, int> freq;\n    int sum = 0;\n    \n    for (int i = 0; i < n; ++i) {\n        freq[arr[i]]++;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        if (freq[arr[i]] == 1) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}", "unique_id": "MBCPP_777_5", "index": 6764}
{"task_id": "MBCPP/780", "completion": "    vector<vector<int>> result;\n    int n = testList.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = 0; k < 2; ++k) {\n                for (int l = 0; l < 2; ++l) {\n                    result.push_back({testList[i][k] + testList[j][l], testList[j][l] + testList[i][k]});\n                }\n            }\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_780_1", "index": 6770}
{"task_id": "MBCPP/781", "completion": "    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (n % i == 0) {\n            ++count;\n        }\n    }\n    return (count % 2 == 0) ? \"Even\" : \"Odd\";\n}", "unique_id": "MBCPP_781_9", "index": 6788}
{"task_id": "MBCPP/782", "completion": "    int sum = 0;\n    int n = arr.size();\n    for (int i = 0; i < n; ++i) {\n        int end = i + 1;\n        int start = n - i;\n        int totalSubarrays = end * start;\n        int oddSubarrays = (totalSubarrays + 1) / 2;\n        sum += oddSubarrays * arr[i];\n    }\n    return sum;\n}", "unique_id": "MBCPP_782_2", "index": 6791}
{"task_id": "MBCPP/784", "completion": "    int first_even = -1, first_odd = -1;\n    for (int num : list1) {\n        if (num % 2 == 0 && first_even == -1) {\n            first_even = num;\n        }\n        if (num % 2 != 0 && first_odd == -1) {\n            first_odd = num;\n        }\n        if (first_even != -1 && first_odd != -1) {\n            break;\n        }\n    }\n    return (first_even == -1 || first_odd == -1) ? 0 : first_even * first_odd;\n}", "unique_id": "MBCPP_784_10", "index": 6809}
{"task_id": "MBCPP/785", "completion": "    vector<int> result;\n    string num;\n    for (char c : testStr) {\n        if (isdigit(c) || c == '-') {\n            num += c;\n        } else if (!num.empty()) {\n            result.push_back(stoi(num));\n            num.clear();\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_785_3", "index": 6812}
{"task_id": "MBCPP/786", "completion": "    return upper_bound(a.begin(), a.end(), x) - a.begin();\n}", "unique_id": "MBCPP_786_3", "index": 6822}
{"task_id": "MBCPP/787", "completion": "    regex pattern(\"ab{3}\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_787_1", "index": 6830}
{"task_id": "MBCPP/788", "completion": "    testList.push_back(testStr);\n    return testList;\n}", "unique_id": "MBCPP_788_8", "index": 6847}
{"task_id": "MBCPP/789", "completion": "    return s * l;\n}", "unique_id": "MBCPP_789_4", "index": 6853}
{"task_id": "MBCPP/790", "completion": "    for (int i = 0; i < nums.size(); i += 2) {\n        if (nums[i] % 2 != 0) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_790_5", "index": 6864}
{"task_id": "MBCPP/792", "completion": "    return inputList.size();\n}", "unique_id": "MBCPP_792_8", "index": 6877}
{"task_id": "MBCPP/793", "completion": "    int low = 0, high = n - 1;\n    int result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (arr[mid] == x) {\n            result = mid;\n            low = mid + 1;\n        } else if (arr[mid] < x) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_793_5", "index": 6884}
{"task_id": "MBCPP/794", "completion": "    if (text.front() == 'a' && text.back() == 'b') {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_794_9", "index": 6898}
{"task_id": "MBCPP/796", "completion": "    int sum = 0;\n    for (const auto& item : dict) {\n        sum += item.second;\n    }\n    return sum;\n}", "unique_id": "MBCPP_796_4", "index": 6903}
{"task_id": "MBCPP/797", "completion": "    int sum = 0;\n    for (int i = l; i <= r; i++) {\n        if (i % 2 != 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_797_4", "index": 6913}
{"task_id": "MBCPP/798", "completion": "    int total = 0;\n    for (int num : arr) {\n        total += num;\n    }\n    return total;\n}", "unique_id": "MBCPP_798_5", "index": 6924}
{"task_id": "MBCPP/799", "completion": "    int bits = sizeof(n) * 8;\n    return (n << d) | (n >> (bits - d));\n}", "unique_id": "MBCPP_799_1", "index": 6930}
{"task_id": "MBCPP/800", "completion": "    text.erase(remove(text.begin(), text.end(), ' '), text.end());\n    return text;\n}", "unique_id": "MBCPP_800_6", "index": 6945}
{"task_id": "MBCPP/801", "completion": "    if (x == y && y == z) \n        return 3;\n    else if (x == y || y == z || x == z)\n        return 2;\n    else\n        return 0;\n}", "unique_id": "MBCPP_801_9", "index": 6958}
{"task_id": "MBCPP/802", "completion": "    int min_index = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n    return min_index;\n}", "unique_id": "MBCPP_802_6", "index": 6965}
{"task_id": "MBCPP/803", "completion": "    if (n < 0)\n        return false;\n    int sqrt_n = sqrt(n);\n    return sqrt_n * sqrt_n == n;\n}", "unique_id": "MBCPP_803_9", "index": 6978}
{"task_id": "MBCPP/804", "completion": "    for (int i = 0; i < n; i++) {\n        if (arr[i] % 2 == 0) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_804_8", "index": 6987}
{"task_id": "MBCPP/805", "completion": "    vector<int> maxList;\n    int maxSum = INT_MIN;\n    for (const auto& list : lists) {\n        int currentSum = accumulate(list.begin(), list.end(), 0);\n        if (currentSum > maxSum) {\n            maxSum = currentSum;\n            maxList = list;\n        }\n    }\n    return maxList;\n}", "unique_id": "MBCPP_805_4", "index": 6993}
{"task_id": "MBCPP/806", "completion": "    int max_run = 0, current_run = 0;\n    for (char c : testStr) {\n        if (isupper(c)) {\n            current_run++;\n            max_run = max(max_run, current_run);\n        } else {\n            current_run = 0;\n        }\n    }\n    return max_run;\n}", "unique_id": "MBCPP_806_7", "index": 7006}
{"task_id": "MBCPP/807", "completion": "    for(int num : nums) {\n        if(num % 2 != 0) {\n            return num;\n        }\n    }\n    return -1; // Return -1 if no odd number is found\n}", "unique_id": "MBCPP_807_9", "index": 7018}
{"task_id": "MBCPP/808", "completion": "    return find(testTup.begin(), testTup.end(), k) != testTup.end();\n}", "unique_id": "MBCPP_808_8", "index": 7027}
{"task_id": "MBCPP/809", "completion": "    for (size_t i = 0; i < testTup1.size(); ++i) {\n        if (testTup2[i] >= testTup1[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_809_9", "index": 7038}
{"task_id": "MBCPP/810", "completion": "    vector<string> result;\n    vector<int> counts = {a, b, c, d};\n    char ch = 'p';\n    \n    for (int count : counts) {\n        for (int i = 0; i < count; ++i) {\n            result.push_back(string(1, ch));\n        }\n        ++ch;\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_810_10", "index": 7049}
{"task_id": "MBCPP/811", "completion": "    return testList1 == testList2;\n}", "unique_id": "MBCPP_811_4", "index": 7053}
{"task_id": "MBCPP/812", "completion": "    size_t pos = street.find(\" Road\");\n    if (pos != string::npos) {\n        street.replace(pos, 5, \" Rd.\");\n    }\n    return street;\n}", "unique_id": "MBCPP_812_4", "index": 7063}
{"task_id": "MBCPP/813", "completion": "    return str1.length();\n}", "unique_id": "MBCPP_813_5", "index": 7074}
{"task_id": "MBCPP/814", "completion": "    return (p * q) / 2;\n}", "unique_id": "MBCPP_814_5", "index": 7084}
{"task_id": "MBCPP/815", "completion": "    int low = 0, mid = 0, high = n - 1;\n    while (mid <= high) {\n        switch (arr[mid]) {\n            case 0:\n                swap(arr[low++], arr[mid++]);\n                break;\n            case 1:\n                mid++;\n                break;\n            case 2:\n                swap(arr[mid], arr[high--]);\n                break;\n        }\n    }\n    return arr;\n}", "unique_id": "MBCPP_815_4", "index": 7093}
{"task_id": "MBCPP/817", "completion": "    vector<int> result;\n    for_each(nums.begin(), nums.end(), [&](int num) {\n        if (num % m == 0 || num % n == 0) {\n            result.push_back(num);\n        }\n    });\n    return result;\n}", "unique_id": "MBCPP_817_3", "index": 7102}
{"task_id": "MBCPP/818", "completion": "    int count = 0;\n    for (char c : str) {\n        if (islower(c)) {\n            count++;\n        }\n    }\n    return count;\n}", "unique_id": "MBCPP_818_10", "index": 7119}
{"task_id": "MBCPP/819", "completion": "    vector<int> elements;\n    vector<int> counts;\n    \n    if (lists.empty()) {\n        return {elements, counts};\n    }\n\n    int currentElement = lists[0];\n    int count = 1;\n\n    for (int i = 1; i < lists.size(); ++i) {\n        if (lists[i] == currentElement) {\n            count++;\n        } else {\n            elements.push_back(currentElement);\n            counts.push_back(count);\n            currentElement = lists[i];\n            count = 1;\n        }\n    }\n    \n    elements.push_back(currentElement);\n    counts.push_back(count);\n\n    return {elements, counts};\n}", "unique_id": "MBCPP_819_9", "index": 7128}
{"task_id": "MBCPP/820", "completion": "    return monthnum1 == 2;\n}", "unique_id": "MBCPP_820_8", "index": 7137}
{"task_id": "MBCPP/821", "completion": "    unordered_map<string, string> mergedDict = dict1;\n    for (const auto& pair : dict2) {\n        mergedDict[pair.first] = pair.second;\n    }\n    return mergedDict;\n}", "unique_id": "MBCPP_821_3", "index": 7142}
{"task_id": "MBCPP/822", "completion": "    if (p.length() < 8)\n        return false;\n\n    bool hasLower = false, hasUpper = false, hasDigit = false, hasSpecial = false;\n\n    for (char c : p) {\n        if (islower(c)) hasLower = true;\n        else if (isupper(c)) hasUpper = true;\n        else if (isdigit(c)) hasDigit = true;\n        else hasSpecial = true;\n    }\n\n    return hasLower && hasUpper && hasDigit && hasSpecial;\n}", "unique_id": "MBCPP_822_10", "index": 7159}
{"task_id": "MBCPP/823", "completion": "    regex pattern(\"^\" + sample);\n    if (regex_search(str, pattern)) {\n        return \"string starts with the given substring\";\n    } else {\n        return \"string doesnt start with the given substring\";\n    }\n}", "unique_id": "MBCPP_823_1", "index": 7160}
{"task_id": "MBCPP/824", "completion": "    vector<int> result;\n    for (int num : l) {\n        if (num % 2 != 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_824_3", "index": 7172}
{"task_id": "MBCPP/825", "completion": "    vector<int> result;\n    for (int index : listIndex) {\n        if (index >= 0 && index < nums.size()) {\n            result.push_back(nums[index]);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_825_8", "index": 7187}
{"task_id": "MBCPP/826", "completion": "    if (a <= 0 || b <= 0 || c <= 0 || a + b <= c || a + c <= b || b + c <= a) {\n        return \"Not a Triangle\";\n    }\n    int a2 = a * a, b2 = b * b, c2 = c * c;\n    if (a2 + b2 == c2 || a2 + c2 == b2 || b2 + c2 == a2) {\n        return \"Right-angled Triangle\";\n    }\n    if (a2 + b2 < c2 || a2 + c2 < b2 || b2 + c2 < a2) {\n        return \"Obtuse-angled Triangle\";\n    }\n    return \"Acute-angled Triangle\";\n}", "unique_id": "MBCPP_826_1", "index": 7190}
{"task_id": "MBCPP/827", "completion": "    int sum = 0;\n    for (const auto& row : list1) {\n        if (c < row.size()) {\n            sum += row[c];\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_827_8", "index": 7207}
{"task_id": "MBCPP/828", "completion": "    int alphabets = 0, digits = 0, special = 0;\n    for (char ch : str) {\n        if (isalpha(ch))\n            alphabets++;\n        else if (isdigit(ch))\n            digits++;\n        else\n            special++;\n    }\n    return {alphabets, digits, special};\n}", "unique_id": "MBCPP_828_5", "index": 7214}
{"task_id": "MBCPP/829", "completion": "    unordered_map<string, int> freq;\n    for (const auto& str : input) {\n        freq[str]++;\n    }\n\n    int first_max = INT_MIN, second_max = INT_MIN;\n    string first, second;\n    \n    for (const auto& entry : freq) {\n        if (entry.second > first_max) {\n            second_max = first_max;\n            second = first;\n            first_max = entry.second;\n            first = entry.first;\n        } else if (entry.second > second_max && entry.second != first_max) {\n            second_max = entry.second;\n            second = entry.first;\n        }\n    }\n\n    return second;\n}", "unique_id": "MBCPP_829_4", "index": 7223}
{"task_id": "MBCPP/831", "completion": "    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    int pairs = 0;\n    for (auto it : freq) {\n        int count = it.second;\n        pairs += (count * (count - 1)) / 2;\n    }\n    return pairs;\n}", "unique_id": "MBCPP_831_10", "index": 7239}
{"task_id": "MBCPP/832", "completion": "    regex re(\"\\\\d+\");\n    sregex_iterator next(input.begin(), input.end(), re);\n    sregex_iterator end;\n    int maxVal = 0;\n    while (next != end) {\n        smatch match = *next;\n        int value = stoi(match.str());\n        if (value > maxVal) {\n            maxVal = value;\n        }\n        next++;\n    }\n    return maxVal;\n}", "unique_id": "MBCPP_832_1", "index": 7240}
{"task_id": "MBCPP/833", "completion": "    vector<int> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n    return keys;\n}", "unique_id": "MBCPP_833_9", "index": 7258}
{"task_id": "MBCPP/834", "completion": "    vector<vector<int>> matrix(n, vector<int>(n, 0));\n    int left = 0, right = n - 1, top = 0, bottom = n - 1;\n    int num = 1;\n\n    while (left <= right && top <= bottom) {\n        for (int i = left; i <= right; ++i) {\n            matrix[top][i] = num++;\n        }\n        ++top;\n        for (int i = top; i <= bottom; ++i) {\n            matrix[i][right] = num++;\n        }\n        --right;\n        if (top <= bottom) {\n            for (int i = right; i >= left; --i) {\n                matrix[bottom][i] = num++;\n            }\n            --bottom;\n        }\n        if (left <= right) {\n            for (int i = bottom; i >= top; --i) {\n                matrix[i][left] = num++;\n            }\n            ++left;\n        }\n    }\n\n    return matrix;\n}", "unique_id": "MBCPP_834_9", "index": 7268}
{"task_id": "MBCPP/836", "completion": "    int max_so_far = INT_MIN, max_ending_here = 0;\n    int start = 0, end = 0, s = 0;\n    \n    for (int i = 0; i < size; i++) {\n        max_ending_here += a[i];\n        \n        if (max_so_far < max_ending_here) {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n        \n        if (max_ending_here < 0) {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    \n    return end - start + 1;\n}", "unique_id": "MBCPP_836_10", "index": 7279}
{"task_id": "MBCPP/837", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; ++i) {\n        int oddNum = 2 * i - 1;\n        sum += oddNum * oddNum * oddNum;\n    }\n    return sum;\n}", "unique_id": "MBCPP_837_4", "index": 7283}
{"task_id": "MBCPP/838", "completion": "    int count1[2] = {0, 0};\n    int count2[2] = {0, 0};\n\n    for (char c : s1) count1[c - '0']++;\n    for (char c : s2) count2[c - '0']++;\n\n    if (count1[0] != count2[0] || count1[1] != count2[1])\n        return -1;\n\n    int swaps = 0;\n    int x_mismatch = 0, y_mismatch = 0;\n\n    for (int i = 0; i < s1.size(); i++) {\n        if (s1[i] == '0' && s2[i] == '1') x_mismatch++;\n        if (s1[i] == '1' && s2[i] == '0') y_mismatch++;\n    }\n\n    swaps = (x_mismatch / 2) + (y_mismatch / 2) + (x_mismatch % 2) * 2;\n\n    return swaps;\n}", "unique_id": "MBCPP_838_1", "index": 7290}
{"task_id": "MBCPP/840", "completion": "    int discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return \"No\";\n    }\n    double root1 = (-b + sqrt(discriminant)) / (2 * a);\n    double root2 = (-b - sqrt(discriminant)) / (2 * a);\n    if (root1 == -root2) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}", "unique_id": "MBCPP_840_2", "index": 7301}
{"task_id": "MBCPP/841", "completion": "    int inv_count = 0;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (arr[i] > arr[j]) {\n                inv_count++;\n            }\n        }\n    }\n    return inv_count;\n}", "unique_id": "MBCPP_841_8", "index": 7317}
{"task_id": "MBCPP/842", "completion": "    unordered_map<int, int> freq;\n    for (int num : arr) {\n        freq[num]++;\n    }\n    for (const auto& pair : freq) {\n        if (pair.second % 2 != 0) {\n            return pair.first;\n        }\n    }\n    return -1;\n}", "unique_id": "MBCPP_842_6", "index": 7325}
{"task_id": "MBCPP/843", "completion": "    vector<int> uglyNumbers(n, INT_MAX);\n    uglyNumbers[0] = 1;\n    int k = primes.size();\n    vector<int> indices(k, 0);\n    vector<int> nextMultiple(k);\n\n    for (int i = 0; i < k; ++i) {\n        nextMultiple[i] = primes[i];\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int nextUgly = *min_element(nextMultiple.begin(), nextMultiple.end());\n        uglyNumbers[i] = nextUgly;\n\n        for (int j = 0; j < k; ++j) {\n            if (nextUgly == nextMultiple[j]) {\n                indices[j]++;\n                nextMultiple[j] = uglyNumbers[indices[j]] * primes[j];\n            }\n        }\n    }\n\n    return uglyNumbers[n - 1];\n}", "unique_id": "MBCPP_843_6", "index": 7335}
{"task_id": "MBCPP/844", "completion": "    if (k <= (n + 1) / 2) {\n        return 2 * k - 1;\n    } else {\n        return 2 * (k - (n + 1) / 2);\n    }\n}", "unique_id": "MBCPP_844_1", "index": 7340}
{"task_id": "MBCPP/845", "completion": "    if (n == 0 || n == 1)\n        return 1;\n    \n    double digits = 0;\n    for (int i = 2; i <= n; i++) {\n        digits += log10(i);\n    }\n    \n    return floor(digits) + 1;\n}", "unique_id": "MBCPP_845_3", "index": 7352}
{"task_id": "MBCPP/846", "completion": "    sort(arr.begin(), arr.end());\n    sort(dep.begin(), dep.end());\n\n    int platforms_needed = 1, result = 1;\n    int i = 1, j = 0;\n\n    while (i < n && j < n) {\n        if (arr[i] <= dep[j]) {\n            platforms_needed++;\n            i++;\n        } else {\n            platforms_needed--;\n            j++;\n        }\n        if (platforms_needed > result)\n            result = platforms_needed;\n    }\n\n    return result;\n}", "unique_id": "MBCPP_846_6", "index": 7365}
{"task_id": "MBCPP/847", "completion": "    return xs;\n}", "unique_id": "MBCPP_847_7", "index": 7376}
{"task_id": "MBCPP/848", "completion": "    return ((base1 + base2) * height) / 2;\n}", "unique_id": "MBCPP_848_4", "index": 7383}
{"task_id": "MBCPP/849", "completion": "    int result = 0;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            bool isPrime = true;\n            for (int j = 2; j * j <= i; ++j) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                result += i;\n            }\n            while (n % i == 0) {\n                n /= i;\n            }\n        }\n    }\n    if (n > 1) {\n        result += n;\n    }\n    return result;\n}", "unique_id": "MBCPP_849_4", "index": 7393}
{"task_id": "MBCPP/850", "completion": "    return (a > 0 && b > 0 && c > 0 && (a + b + c) == 180);\n}", "unique_id": "MBCPP_850_6", "index": 7405}
{"task_id": "MBCPP/852", "completion": "    vector<int> result;\n    for (int num : numList) {\n        if (num >= 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_852_8", "index": 7417}
{"task_id": "MBCPP/853", "completion": "    int sum = 0;\n    for (int i = 1; i <= n; i += 2) {\n        if (n % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_853_2", "index": 7421}
{"task_id": "MBCPP/854", "completion": "    make_heap(rawheap.begin(), rawheap.end(), greater<int>());\n    sort_heap(rawheap.begin(), rawheap.end(), greater<int>());\n    return rawheap;\n}", "unique_id": "MBCPP_854_1", "index": 7430}
{"task_id": "MBCPP/855", "completion": "    return __builtin_popcount(x) % 2 == 0;\n}", "unique_id": "MBCPP_855_7", "index": 7446}
{"task_id": "MBCPP/856", "completion": "    int count_zero = 0, swaps = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == 0)\n            count_zero++;\n        else\n            swaps += count_zero;\n    }\n    return swaps;\n}", "unique_id": "MBCPP_856_5", "index": 7454}
{"task_id": "MBCPP/857", "completion": "    vector<vector<string>> result;\n    for (const auto& str : list1) {\n        vector<string> temp;\n        for (const auto& ch : str) {\n            temp.push_back(string(1, ch));\n        }\n        result.push_back(temp);\n    }\n    return result;\n}", "unique_id": "MBCPP_857_9", "index": 7468}
{"task_id": "MBCPP/858", "completion": "    int count = inputList.size();\n    return count * count;\n}", "unique_id": "MBCPP_858_3", "index": 7472}
{"task_id": "MBCPP/860", "completion": "    if (regex_search(str, regex(\"[a-zA-Z0-9]$\"))) {\n        return \"Accept\";\n    } else {\n        return \"Discard\";\n    }\n}", "unique_id": "MBCPP_860_3", "index": 7482}
{"task_id": "MBCPP/861", "completion": "    vector<string> result;\n    auto isAnagram = [](string a, string b) {\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n        return a == b;\n    };\n    for (const auto& text : texts) {\n        if (isAnagram(text, str)) {\n            result.push_back(text);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_861_10", "index": 7499}
{"task_id": "MBCPP/863", "completion": "    unordered_set<int> S(arr.begin(), arr.end());\n    int longest_streak = 0;\n\n    for (int num : arr) {\n        if (S.find(num - 1) == S.end()) {\n            int current_num = num;\n            int current_streak = 1;\n\n            while (S.find(current_num + 1) != S.end()) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = max(longest_streak, current_streak);\n        }\n    }\n\n    return longest_streak;\n}", "unique_id": "MBCPP_863_7", "index": 7506}
{"task_id": "MBCPP/864", "completion": "    vector<string> result;\n    auto isPalindrome = [](const string &s) {\n        return s == string(s.rbegin(), s.rend());\n    };\n    copy_if(texts.begin(), texts.end(), back_inserter(result), isPalindrome);\n    return result;\n}", "unique_id": "MBCPP_864_7", "index": 7516}
{"task_id": "MBCPP/865", "completion": "    vector<int> result;\n    transform(nums.begin(), nums.end(), back_inserter(result), [n](int num) { return num * n; });\n    return result;\n}", "unique_id": "MBCPP_865_9", "index": 7528}
{"task_id": "MBCPP/866", "completion": "    unordered_set<string> months_with_31_days = {\"January\", \"March\", \"May\", \"July\", \"August\", \"October\", \"December\"};\n    return months_with_31_days.find(monthname2) != months_with_31_days.end();\n}", "unique_id": "MBCPP_866_4", "index": 7533}
{"task_id": "MBCPP/867", "completion": "    int sum = accumulate(arr.begin(), arr.end(), 0);\n    return sum % 2 == 0 ? 2 : 1;\n}", "unique_id": "MBCPP_867_6", "index": 7545}
{"task_id": "MBCPP/868", "completion": "    int length = 0;\n    int i = a.size() - 1;\n    \n    // Remove trailing spaces\n    while (i >= 0 && a[i] == ' ')\n        i--;\n    \n    // Count the length of the last word\n    while (i >= 0 && a[i] != ' ') {\n        length++;\n        i--;\n    }\n    \n    return length;\n}", "unique_id": "MBCPP_868_3", "index": 7552}
{"task_id": "MBCPP/869", "completion": "    vector<vector<int>> result;\n    for (const auto& sublist : list1) {\n        bool inRange = true;\n        for (const auto& num : sublist) {\n            if (num < leftrange || num > rigthrange) {\n                inRange = false;\n                break;\n            }\n        }\n        if (inRange) {\n            result.push_back(sublist);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_869_7", "index": 7566}
{"task_id": "MBCPP/870", "completion": "    return accumulate(nums.begin(), nums.end(), 0, [](int sum, int num) {\n        return num > 0 ? sum + num : sum;\n    });\n}", "unique_id": "MBCPP_870_1", "index": 7570}
{"task_id": "MBCPP/871", "completion": "    if (string1.length() != string2.length())\n        return false;\n    string temp = string1 + string1;\n    return (temp.find(string2) != string::npos);\n}", "unique_id": "MBCPP_871_4", "index": 7583}
{"task_id": "MBCPP/873", "completion": "    if (n <= 1)\n        return n;\n    else\n        return fibonacci(n - 1) + fibonacci(n - 2);\n}", "unique_id": "MBCPP_873_2", "index": 7591}
{"task_id": "MBCPP/874", "completion": "    if (str2.empty() || str1.empty() || str1.size() % str2.size() != 0) {\n        return false;\n    }\n    string repeated = \"\";\n    int repeatCount = str1.size() / str2.size();\n    for (int i = 0; i < repeatCount; ++i) {\n        repeated += str2;\n    }\n    return repeated == str1;\n}", "unique_id": "MBCPP_874_9", "index": 7608}
{"task_id": "MBCPP/875", "completion": "    int min_diff = INT_MAX;\n    for (const auto& pair : testList) {\n        int diff = abs(pair[0] - pair[1]);\n        min_diff = min(min_diff, diff);\n    }\n    return min_diff;\n}", "unique_id": "MBCPP_875_2", "index": 7611}
{"task_id": "MBCPP/876", "completion": "    return (x * y) / __gcd(x, y);\n}", "unique_id": "MBCPP_876_5", "index": 7624}
{"task_id": "MBCPP/877", "completion": "    sort(str.begin(), str.end());\n    return str;\n}", "unique_id": "MBCPP_877_6", "index": 7635}
{"task_id": "MBCPP/878", "completion": "    unordered_set<int> set_k(k.begin(), k.end());\n    for (int num : testTuple) {\n        if (set_k.find(num) == set_k.end()) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_878_7", "index": 7646}
{"task_id": "MBCPP/879", "completion": "    regex pattern(\"a.*b$\");\n    if (regex_match(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_879_10", "index": 7659}
{"task_id": "MBCPP/880", "completion": "    int discriminant = b * b - 4 * a * c;\n    if (discriminant > 0) {\n        return \"2 solutions\";\n    } else if (discriminant == 0) {\n        return \"1 solution\";\n    } else {\n        return \"No solutions\";\n    }\n}", "unique_id": "MBCPP_880_9", "index": 7668}
{"task_id": "MBCPP/881", "completion": "    int even = 0, odd = 0;\n    bool found_even = false, found_odd = false;\n\n    for (int num : list1) {\n        if (!found_even && num % 2 == 0) {\n            even = num;\n            found_even = true;\n        }\n        if (!found_odd && num % 2 != 0) {\n            odd = num;\n            found_odd = true;\n        }\n        if (found_even && found_odd) {\n            break;\n        }\n    }\n\n    return even + odd;\n}", "unique_id": "MBCPP_881_9", "index": 7678}
{"task_id": "MBCPP/882", "completion": "    return 2 * (b + h);\n}", "unique_id": "MBCPP_882_10", "index": 7689}
{"task_id": "MBCPP/883", "completion": "    vector<int> result;\n    for (int num : nums) {\n        if ([m, n](int x) { return x % m == 0 && x % n == 0; }(num)) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_883_1", "index": 7690}
{"task_id": "MBCPP/884", "completion": "    for (int i = l; i <= r; ++i) {\n        if ((n & (1 << i)) == 0) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_884_4", "index": 7703}
{"task_id": "MBCPP/885", "completion": "    if (str1.length() != str2.length()) {\n        return false;\n    }\n\n    unordered_map<char, char> map1, map2;\n    for (int i = 0; i < str1.length(); ++i) {\n        char c1 = str1[i], c2 = str2[i];\n\n        if (map1.count(c1) && map1[c1] != c2) {\n            return false;\n        }\n        if (map2.count(c2) && map2[c2] != c1) {\n            return false;\n        }\n\n        map1[c1] = c2;\n        map2[c2] = c1;\n    }\n\n    return true;\n}", "unique_id": "MBCPP_885_2", "index": 7711}
{"task_id": "MBCPP/886", "completion": "    double sum = accumulate(numbers.begin(), numbers.end(), 0);\n    return sum / numbers.size();\n}", "unique_id": "MBCPP_886_9", "index": 7728}
{"task_id": "MBCPP/887", "completion": "    return n & 1;\n}", "unique_id": "MBCPP_887_4", "index": 7733}
{"task_id": "MBCPP/888", "completion": "    vector<vector<int>> result;\n    for (size_t i = 0; i < testTup1.size(); ++i) {\n        vector<int> row;\n        for (size_t j = 0; j < testTup1[i].size(); ++j) {\n            row.push_back(testTup1[i][j] - testTup2[i][j]);\n        }\n        result.push_back(row);\n    }\n    return result;\n}", "unique_id": "MBCPP_888_8", "index": 7747}
{"task_id": "MBCPP/889", "completion": "    for (auto &list : lists) {\n        reverse(list.begin(), list.end());\n    }\n    return lists;\n}", "unique_id": "MBCPP_889_10", "index": 7759}
{"task_id": "MBCPP/890", "completion": "    for (int i = 0; i < n; ++i) {\n        if (arr1[i] != arr2[i]) {\n            return i;\n        }\n    }\n    return n;\n}", "unique_id": "MBCPP_890_10", "index": 7769}
{"task_id": "MBCPP/891", "completion": "    return to_string(a).length() == to_string(b).length();\n}", "unique_id": "MBCPP_891_1", "index": 7770}
{"task_id": "MBCPP/892", "completion": "    string result;\n    bool inSpace = false;\n    for (char c : text) {\n        if (isspace(c)) {\n            if (!inSpace) {\n                result += ' ';\n                inSpace = true;\n            }\n        } else {\n            result += c;\n            inSpace = false;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_892_7", "index": 7786}
{"task_id": "MBCPP/894", "completion": "    vector<double> result;\n    stringstream ss(testStr);\n    string token;\n    while (getline(ss, token, ',')) {\n        result.push_back(stod(token));\n    }\n    return result;\n}", "unique_id": "MBCPP_894_8", "index": 7797}
{"task_id": "MBCPP/895", "completion": "    int n = a.size();\n    if (n == 0) return 0;\n    if (n == 1) return a[0];\n    \n    vector<int> dp(n);\n    dp[0] = a[0];\n    dp[1] = max(a[0], a[1]);\n    \n    for (int i = 2; i < n; ++i) {\n        dp[i] = max(dp[i-1], dp[i-2] + a[i]);\n    }\n    \n    return dp[n-1];\n}", "unique_id": "MBCPP_895_7", "index": 7806}
{"task_id": "MBCPP/896", "completion": "    sort(tuples.begin(), tuples.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.back() < b.back();\n    });\n    return tuples;\n}", "unique_id": "MBCPP_896_5", "index": 7814}
{"task_id": "MBCPP/897", "completion": "    return sentence.find(word) != string::npos;\n}", "unique_id": "MBCPP_897_9", "index": 7828}
{"task_id": "MBCPP/898", "completion": "    vector<int> result;\n    int count = 1;\n    \n    for (int i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] == numbers[i - 1]) {\n            count++;\n            if (count == n) {\n                result.push_back(numbers[i]);\n                count = 0; // Reset count after finding a complete sequence\n            }\n        } else {\n            count = 1;\n        }\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_898_1", "index": 7830}
{"task_id": "MBCPP/899", "completion": "    int left = 0, right = n - 1;\n    int last = INT_MIN;\n\n    while (left <= right) {\n        if (arr[left] <= arr[right]) {\n            if (arr[left] < last) {\n                return false;\n            }\n            last = arr[left];\n            left++;\n        } else {\n            if (arr[right] < last) {\n                return false;\n            }\n            last = arr[right];\n            right--;\n        }\n    }\n\n    return true;\n}", "unique_id": "MBCPP_899_6", "index": 7845}
{"task_id": "MBCPP/900", "completion": "    return !str.empty() && isdigit(str[0]) && str[0] == '5';\n}", "unique_id": "MBCPP_900_9", "index": 7858}
{"task_id": "MBCPP/901", "completion": "    auto lcm = [](int a, int b) {\n        return a / __gcd(a, b) * b;\n    };\n    int result = 1;\n    for (int i = 2; i <= n; ++i) {\n        result = lcm(result, i);\n    }\n    return result;\n}", "unique_id": "MBCPP_901_4", "index": 7863}
{"task_id": "MBCPP/902", "completion": "    for (auto& pair : d2) {\n        d1[pair.first] += pair.second;\n    }\n    return d1;\n}", "unique_id": "MBCPP_902_2", "index": 7871}
{"task_id": "MBCPP/903", "completion": "    int totalUnsetBits = 0;\n    for (int i = 1; i <= n; ++i) {\n        int num = i;\n        while (num > 0) {\n            if ((num & 1) == 0) {\n                totalUnsetBits++;\n            }\n            num >>= 1;\n        }\n        totalUnsetBits += (sizeof(int) * 8) - __builtin_popcount(i);\n    }\n    return totalUnsetBits;\n}", "unique_id": "MBCPP_903_1", "index": 7880}
{"task_id": "MBCPP/905", "completion": "    int result = 0;\n    int C[n + 1][n + 1];\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (j == 0 || j == i)\n                C[i][j] = 1;\n            else\n                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i <= n; i++) {\n        result += C[n][i] * C[n][i];\n    }\n\n    return result;\n}", "unique_id": "MBCPP_905_3", "index": 7892}
{"task_id": "MBCPP/906", "completion": "    vector<vector<string>> result;\n    regex date_pattern(R\"((\\d{4})/(\\d{2})/(\\d{2}))\");\n    smatch match;\n    \n    while (regex_search(url, match, date_pattern)) {\n        result.push_back({match[1], match[2], match[3]});\n        url = match.suffix();\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_906_2", "index": 7901}
{"task_id": "MBCPP/907", "completion": "    vector<int> lucky;\n    int num = 1;\n    while (lucky.size() < n) {\n        if (num % 2 != 0 && num % 5 != 0) {\n            lucky.push_back(num);\n        }\n        num++;\n    }\n    return lucky;\n}", "unique_id": "MBCPP_907_2", "index": 7911}
{"task_id": "MBCPP/908", "completion": "    for(int i = 0; i < n; i++) {\n        if(arr[i] == i) {\n            return i;\n        }\n    }\n    return -1;\n}", "unique_id": "MBCPP_908_10", "index": 7929}
{"task_id": "MBCPP/909", "completion": "    num--;\n    while (true) {\n        string s = to_string(num);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        if (s == rev_s) {\n            return num;\n        }\n        num--;\n    }\n}", "unique_id": "MBCPP_909_2", "index": 7931}
{"task_id": "MBCPP/911", "completion": "    priority_queue<int> maxHeap(nums.begin(), nums.end());\n    priority_queue<int, vector<int>, greater<int>> minHeap(nums.begin(), nums.end());\n    \n    // Extract the three largest elements\n    int a = maxHeap.top(); maxHeap.pop();\n    int b = maxHeap.top(); maxHeap.pop();\n    int c = maxHeap.top(); maxHeap.pop();\n    \n    // Extract the two smallest elements\n    int x = minHeap.top(); minHeap.pop();\n    int y = minHeap.top(); minHeap.pop();\n    \n    return max(a * b * c, a * x * y);\n}", "unique_id": "MBCPP_911_10", "index": 7949}
{"task_id": "MBCPP/912", "completion": "    return (2 * m + 1) * tgamma(n + m + 1) / (tgamma(n - m + 1) * tgamma(m + 2));\n}", "unique_id": "MBCPP_912_1", "index": 7950}
{"task_id": "MBCPP/913", "completion": "    if (str.empty()) return false;\n    return isdigit(str.back());\n}", "unique_id": "MBCPP_913_9", "index": 7968}
{"task_id": "MBCPP/914", "completion": "    if (s.length() < 2) return false;\n    char first = s[0];\n    char second = s[1];\n    if (first == second) return false;\n    for (int i = 0; i < s.length(); ++i) {\n        if ((i % 2 == 0 && s[i] != first) || (i % 2 == 1 && s[i] != second)) {\n            return false;\n        }\n    }\n    return true;\n}", "unique_id": "MBCPP_914_1", "index": 7970}
{"task_id": "MBCPP/915", "completion": "    partition(arrayNums.begin(), arrayNums.end(), [](int x) { return x >= 0; });\n    return arrayNums;\n}", "unique_id": "MBCPP_915_4", "index": 7983}
{"task_id": "MBCPP/916", "completion": "    sort(a.begin(), a.end());\n    for (int i = 0; i < arrSize - 2; i++) {\n        int l = i + 1;\n        int r = arrSize - 1;\n        while (l < r) {\n            int currentSum = a[i] + a[l] + a[r];\n            if (currentSum == sum) {\n                return {a[i], a[l], a[r]};\n            } else if (currentSum < sum) {\n                l++;\n            } else {\n                r--;\n            }\n        }\n    }\n    return {};\n}", "unique_id": "MBCPP_916_8", "index": 7997}
{"task_id": "MBCPP/917", "completion": "    regex pattern(\"[A-Z][a-z]+\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_917_1", "index": 8000}
{"task_id": "MBCPP/918", "completion": "    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    for (int i = 0; i < m; i++) {\n        for (int j = s[i]; j <= n; j++) {\n            dp[j] += dp[j - s[i]];\n        }\n    }\n    return dp[n];\n}", "unique_id": "MBCPP_918_1", "index": 8010}
{"task_id": "MBCPP/919", "completion": "    int result = 1;\n    for (int item : items) {\n        result *= item;\n    }\n    return result;\n}", "unique_id": "MBCPP_919_9", "index": 8028}
{"task_id": "MBCPP/921", "completion": "    vector<vector<int>> result;\n    for (size_t i = 0; i < testTup.size(); i += n) {\n        vector<int> chunk(testTup.begin() + i, testTup.begin() + min(testTup.size(), i + n));\n        result.push_back(chunk);\n    }\n    return result;\n}", "unique_id": "MBCPP_921_7", "index": 8036}
{"task_id": "MBCPP/922", "completion": "    int n = arr.size();\n    if (n < 2) return {};\n    \n    int max1 = INT_MIN, max2 = INT_MIN;\n    int min1 = INT_MAX, min2 = INT_MAX;\n\n    for (int num : arr) {\n        if (num > max1) {\n            max2 = max1;\n            max1 = num;\n        } else if (num > max2) {\n            max2 = num;\n        }\n\n        if (num < min1) {\n            min2 = min1;\n            min1 = num;\n        } else if (num < min2) {\n            min2 = num;\n        }\n    }\n\n    if (max1 * max2 > min1 * min2) {\n        return {max1, max2};\n    } else {\n        return {min1, min2};\n    }\n}", "unique_id": "MBCPP_922_3", "index": 8042}
{"task_id": "MBCPP/923", "completion": "    vector<vector<int>> dp(m + 1, n + 1);\n    for (int i = 0; i <= m; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (x[i - 1] == y[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    return dp[m][n];\n}", "unique_id": "MBCPP_923_7", "index": 8056}
{"task_id": "MBCPP/924", "completion": "    return (x > y) ? x : y;\n}", "unique_id": "MBCPP_924_1", "index": 8060}
{"task_id": "MBCPP/925", "completion": "    int product = 1;\n    for(int num : nums) {\n        product *= num;\n    }\n    return product;\n}", "unique_id": "MBCPP_925_4", "index": 8073}
{"task_id": "MBCPP/926", "completion": "    if (m == 0)\n        return (n == 0) ? 1 : (n == 1) ? 0 : (n - 1) * (rencontresNumber(n - 1, 0) + rencontresNumber(n - 2, 0));\n    if (m == 1)\n        return (n == 1) ? 0 : (n - 1) * rencontresNumber(n - 2, 0);\n    return (n >= m) ? (n - 1) * (rencontresNumber(n - 1, m) + rencontresNumber(n - 2, m - 1)) : 0;\n}", "unique_id": "MBCPP_926_3", "index": 8082}
{"task_id": "MBCPP/928", "completion": "    return dt.substr(8, 2) + \"-\" + dt.substr(5, 2) + \"-\" + dt.substr(0, 4);\n}", "unique_id": "MBCPP_928_5", "index": 8094}
{"task_id": "MBCPP/929", "completion": "    return count(tuplex.begin(), tuplex.end(), value);\n}", "unique_id": "MBCPP_929_9", "index": 8108}
{"task_id": "MBCPP/930", "completion": "    regex pattern(\"a(b*)\");\n    if (regex_search(text, pattern)) {\n        return \"Found a match!\";\n    } else {\n        return \"Not matched!\";\n    }\n}", "unique_id": "MBCPP_930_3", "index": 8112}
{"task_id": "MBCPP/931", "completion": "    int sum = 0;\n    for (int i = 1; i <= number; ++i) {\n        sum += i * i * i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_931_2", "index": 8121}
{"task_id": "MBCPP/932", "completion": "    unordered_set<string> seen;\n    vector<string> result;\n    for (const auto& word : l) {\n        if (seen.find(word) == seen.end()) {\n            result.push_back(word);\n            seen.insert(word);\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_932_4", "index": 8133}
{"task_id": "MBCPP/933", "completion": "    regex pattern(\"([a-z])([A-Z])\");\n    string result = regex_replace(text, pattern, \"$1_$2\");\n    transform(result.begin(), result.end(), result.begin(), ::tolower);\n    return result;\n}", "unique_id": "MBCPP_933_5", "index": 8144}
{"task_id": "MBCPP/934", "completion": "    if (n == 0 || m == 0)\n        return 1;\n    return dealnnoyNum(n - 1, m) + dealnnoyNum(n - 1, m - 1) + dealnnoyNum(n, m - 1);\n}", "unique_id": "MBCPP_934_5", "index": 8154}
{"task_id": "MBCPP/935", "completion": "    int sum = 0;\n    for (int i = 1; i <= number; ++i) {\n        sum += i * i;\n    }\n    return sum;\n}", "unique_id": "MBCPP_935_8", "index": 8167}
{"task_id": "MBCPP/936", "completion": "    unordered_map<int, vector<int>> map;\n    for (const auto& tuple : testList) {\n        map[tuple[0]] = tuple;\n    }\n    vector<vector<int>> result;\n    for (int key : ordList) {\n        result.push_back(map[key]);\n    }\n    return result;\n}", "unique_id": "MBCPP_936_8", "index": 8177}
{"task_id": "MBCPP/937", "completion": "    unordered_map<char, int> freq;\n    for (char c : str1) {\n        freq[c]++;\n    }\n\n    char maxChar = str1[0];\n    int maxCount = 0;\n\n    for (auto &pair : freq) {\n        if (pair.second > maxCount) {\n            maxCount = pair.second;\n            maxChar = pair.first;\n        }\n    }\n\n    return string(1, maxChar);\n}", "unique_id": "MBCPP_937_8", "index": 8187}
{"task_id": "MBCPP/938", "completion": "    int i = 0, j = 0, k = 0;\n    int diff = INT_MAX;\n    vector<int> res(3);\n    \n    while (i < p && j < q && k < r) {\n        int minimum = min(a[i], min(b[j], c[k]));\n        int maximum = max(a[i], max(b[j], c[k]));\n        \n        if (maximum - minimum < diff) {\n            diff = maximum - minimum;\n            res[0] = a[i];\n            res[1] = b[j];\n            res[2] = c[k];\n        }\n        \n        if (diff == 0) break;\n        \n        if (a[i] == minimum) i++;\n        else if (b[j] == minimum) j++;\n        else k++;\n    }\n    \n    return res;\n}", "unique_id": "MBCPP_938_9", "index": 8198}
{"task_id": "MBCPP/940", "completion": "    auto heapify = [](vector<int>& arr, int n, int i) {\n        int largest = i;\n        int left = 2 * i + 1;\n        int right = 2 * i + 2;\n\n        if (left < n && arr[left] > arr[largest])\n            largest = left;\n\n        if (right < n && arr[right] > arr[largest])\n            largest = right;\n\n        if (largest != i) {\n            swap(arr[i], arr[largest]);\n            heapify(arr, n, largest);\n        }\n    };\n\n    int n = arr.size();\n\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n\n    return arr;\n}", "unique_id": "MBCPP_940_2", "index": 8201}
{"task_id": "MBCPP/942", "completion": "    unordered_set<int> elements(testTup.begin(), testTup.end());\n    for (int num : checkList) {\n        if (elements.find(num) != elements.end()) {\n            return true;\n        }\n    }\n    return false;\n}", "unique_id": "MBCPP_942_3", "index": 8212}
{"task_id": "MBCPP/943", "completion": "    vector<int> result;\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    \n    for(int num : num1) {\n        minHeap.push(num);\n    }\n    for(int num : num2) {\n        minHeap.push(num);\n    }\n    \n    while(!minHeap.empty()) {\n        result.push_back(minHeap.top());\n        minHeap.pop();\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_943_9", "index": 8228}
{"task_id": "MBCPP/944", "completion": "    for (int i = 0; i < text.length(); i++) {\n        if (isdigit(text[i])) {\n            cout << i << endl;\n            return i;\n        }\n    }\n    return -1; // if no digit is found\n}", "unique_id": "MBCPP_944_1", "index": 8230}
{"task_id": "MBCPP/945", "completion": "    return unordered_set<string>(t.begin(), t.end());\n}", "unique_id": "MBCPP_945_3", "index": 8242}
{"task_id": "MBCPP/947", "completion": "    if (list1.empty()) return 0;\n    int minLength = INT_MAX;\n    for (const string& word : list1) {\n        minLength = min(minLength, (int)word.length());\n    }\n    return minLength;\n}", "unique_id": "MBCPP_947_3", "index": 8252}
{"task_id": "MBCPP/949", "completion": "    auto digitCount = [](const vector<int>& vec) {\n        int count = 0;\n        for (int num : vec) {\n            count += to_string(num).length();\n        }\n        return count;\n    };\n\n    sort(testList.begin(), testList.end(), [&](const vector<int>& a, const vector<int>& b) {\n        return digitCount(a) < digitCount(b);\n    });\n\n    string result = \"[\";\n    for (size_t i = 0; i < testList.size(); ++i) {\n        result += \"(\";\n        for (size_t j = 0; j < testList[i].size(); ++j) {\n            result += to_string(testList[i][j]);\n            if (j < testList[i].size() - 1) {\n                result += \", \";\n            }\n        }\n        result += \")\";\n        if (i < testList.size() - 1) {\n            result += \", \";\n        }\n    }\n    result += \"]\";\n    return result;\n}", "unique_id": "MBCPP_949_5", "index": 8264}
{"task_id": "MBCPP/950", "completion": "    vector<string> zodiacs = {\"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Goat\"};\n    return zodiacs[year % 12];\n}", "unique_id": "MBCPP_950_1", "index": 8270}
{"task_id": "MBCPP/951", "completion": "    vector<vector<int>> result;\n    for (size_t i = 0; i < testList1.size(); ++i) {\n        vector<int> maxTuple;\n        for (size_t j = 0; j < testList1[i].size(); ++j) {\n            maxTuple.push_back(max(testList1[i][j], testList2[i][j]));\n        }\n        result.push_back(maxTuple);\n    }\n    return result;\n}", "unique_id": "MBCPP_951_8", "index": 8287}
{"task_id": "MBCPP/952", "completion": "    if (r > n) return 0;\n    if (r == 0 || r == n) return 1;\n    vector<int> C(r + 1, 0);\n    C[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = min(i, r); j > 0; j--) {\n            C[j] = (C[j] + C[j - 1]) % p;\n        }\n    }\n    return C[r];\n}", "unique_id": "MBCPP_952_8", "index": 8297}
{"task_id": "MBCPP/953", "completion": "    unordered_set<int> unique_elements(ar.begin(), ar.end());\n    return unique_elements.size();\n}", "unique_id": "MBCPP_953_7", "index": 8306}
{"task_id": "MBCPP/955", "completion": "    int sum = 1; // 1 is a divisor of every number\n    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n            if (i == (n / i))\n                sum += i;\n            else\n                sum += i + (n / i);\n        }\n    }\n    return sum > n;\n}", "unique_id": "MBCPP_955_9", "index": 8318}
{"task_id": "MBCPP/956", "completion": "    vector<string> result;\n    regex re(\"([A-Z][^A-Z]*)\");\n    auto words_begin = sregex_iterator(text.begin(), text.end(), re);\n    auto words_end = sregex_iterator();\n    for (auto it = words_begin; it != words_end; ++it) {\n        result.push_back(it->str());\n    }\n    return result;\n}", "unique_id": "MBCPP_956_10", "index": 8329}
{"task_id": "MBCPP/957", "completion": "    return log2(n & -n) + 1;\n}", "unique_id": "MBCPP_957_5", "index": 8334}
{"task_id": "MBCPP/958", "completion": "    vector<pair<int, string>> valueSymbols = {\n        {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n        {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n        {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}\n    };\n    \n    string roman = \"\";\n    for (const auto &pair : valueSymbols) {\n        while (num >= pair.first) {\n            roman += pair.second;\n            num -= pair.first;\n        }\n    }\n    \n    return roman;\n}", "unique_id": "MBCPP_958_9", "index": 8348}
{"task_id": "MBCPP/960", "completion": "    if (n <= 2)\n        return n;\n    int a = 1, b = 2, c;\n    for (int i = 3; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}", "unique_id": "MBCPP_960_2", "index": 8351}
{"task_id": "MBCPP/961", "completion": "    unordered_map<char, int> roman = {\n        {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, \n        {'C', 100}, {'D', 500}, {'M', 1000}\n    };\n    int result = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (i > 0 && roman[s[i]] > roman[s[i - 1]]) {\n            result += roman[s[i]] - 2 * roman[s[i - 1]];\n        } else {\n            result += roman[s[i]];\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_961_10", "index": 8369}
{"task_id": "MBCPP/962", "completion": "    int sum = 0;\n    for (int i = l; i <= r; ++i) {\n        if (i % 2 == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}", "unique_id": "MBCPP_962_8", "index": 8377}
{"task_id": "MBCPP/964", "completion": "    return s.length() % 2 == 0;\n}", "unique_id": "MBCPP_964_1", "index": 8380}
{"task_id": "MBCPP/965", "completion": "    string result;\n    for (char c : text) {\n        if (isupper(c)) {\n            if (!result.empty()) {\n                result += '_';\n            }\n            result += tolower(c);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}", "unique_id": "MBCPP_965_8", "index": 8397}
{"task_id": "MBCPP/967", "completion": "    string vowels = \"aeiou\";\n    transform(str.begin(), str.end(), str.begin(), ::tolower);\n    for (char v : vowels) {\n        if (str.find(v) == string::npos) {\n            return \"not accepted\";\n        }\n    }\n    return \"accepted\";\n}", "unique_id": "MBCPP_967_9", "index": 8408}
{"task_id": "MBCPP/968", "completion": "    return min(n, min(a-1, b-1));\n}", "unique_id": "MBCPP_968_7", "index": 8416}
{"task_id": "MBCPP/969", "completion": "    unordered_map<int, vector<int>> map;\n    for (const auto& tuple : testList) {\n        map[tuple[0]].push_back(tuple[1]);\n    }\n    \n    vector<vector<int>> result;\n    for (auto& elem : map) {\n        vector<int> merged = {elem.first};\n        merged.insert(merged.end(), elem.second.begin(), elem.second.end());\n        result.push_back(merged);\n    }\n    \n    return result;\n}", "unique_id": "MBCPP_969_2", "index": 8421}
{"task_id": "MBCPP/970", "completion": "    return (x < y) ? x : y;\n}", "unique_id": "MBCPP_970_2", "index": 8431}
{"task_id": "MBCPP/971", "completion": "    vector<int> dp(n + 1, -1);\n    dp[0] = 0;\n    for (int i = 0; i <= n; ++i) {\n        if (dp[i] != -1) {\n            if (i + a <= n) dp[i + a] = max(dp[i + a], dp[i] + 1);\n            if (i + b <= n) dp[i + b] = max(dp[i + b], dp[i] + 1);\n            if (i + c <= n) dp[i + c] = max(dp[i + c], dp[i] + 1);\n        }\n    }\n    return dp[n];\n}", "unique_id": "MBCPP_971_8", "index": 8447}
{"task_id": "MBCPP/972", "completion": "    vector<int> result = testTup1;\n    result.insert(result.end(), testTup2.begin(), testTup2.end());\n    return result;\n}", "unique_id": "MBCPP_972_10", "index": 8459}
{"task_id": "MBCPP/973", "completion": "    int n = s.size();\n    d = d % n; // In case d is greater than the length of the string\n    return s.substr(d) + s.substr(0, d);\n}", "unique_id": "MBCPP_973_1", "index": 8460}
{"task_id": "MBCPP/974", "completion": "    int n = a.size();\n    vector<int> dp = a[n-1];\n    for(int i = n-2; i >= 0; --i) {\n        for(int j = 0; j <= i; ++j) {\n            dp[j] = a[i][j] + min(dp[j], dp[j+1]);\n        }\n    }\n    return dp[0];\n}", "unique_id": "MBCPP_974_3", "index": 8472}
